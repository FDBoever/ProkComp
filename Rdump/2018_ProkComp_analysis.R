####################################################################################################################################################
#	Developed by Frederik De Boever	
#	Last Edited: 02-03-2018
#
#	DOWNSTREAM PANGENOME ANALYSIS AS PART OF PROKCOMP
#	you will have to wait for a full description
#
####################################################################################################################################################

#--------------------------------------------------------------------------------------------
#	Dependencies
#--------------------------------------------------------------------------------------------

library(vegan)
library(seqinr)
library(phangorn)
library(phytools)
library(phenotypicForest)
library(ggpubr)
library(phylolm)
library("ggtree")
library(plyr)
library(ggplot2)
library(viridis)
library(devtools)
library(dplyr)
library(reshape)
library(micropan)
library(ade4)
library(dendextend)
library(pvclust)
library(rgl)
library(factominer)
library(gplots)
library(RColorBrewer)
library(FactoMineR)
library(ggplot2)
library(Hmisc)

#--------------------------------------------------------------------------------------------
#	Load PANGENOME DATA 
#--------------------------------------------------------------------------------------------
# This section will import data generated by ANVIO and PfamScan, and will modulate them to fit further analysis
# Raw datafiles will be split into either abundance and presence/absence matrices, which will be used lateron 
# additionally, we load-in a tab-deliminted file that categorises the genomes, any category is possible
# for convenience in later merging of dataframes, we deduplicate the ANVIO_protein_clusters_summary.txt to only have one record per PC
# we also extract all DUF domains, and construct a seperate set of abundance and presence/Absence datafiles

#---- ANVIO data --------------
ANVIO <- read.table('~/DATA/MarinobacterGenomics/2018_ProkComp/MARINOBACTER_protein_clusters_summary.txt',header=TRUE,sep="\t") #protein clusters
ANVIO $COG_FUNCTION = sub('\\\t.*', '', ANVIO$COG_FUNCTION)

AnvioData <-table(ANVIO $genome_name, ANVIO $protein_cluster_id)
AnvioData = t(AnvioData)
PA_AnvioData = AnvioData
PA_AnvioData[PA_AnvioData>1] <- 1 

#---- PFAM data --------------
PfamData <- read.table('~/DATA/MarinobacterGenomics/2018_ProkComp/PfamScan_output.csv',header=TRUE,sep='\t')
PfamData = table(PfamData$genome, PfamData$domain)
PAPfamData = PfamData
PAPfamData[PAPfamData>1] <- 1 

#---- PFAM data --------------
#generate a dataframe that contains only the DUF domains 
DUFData = PfamData[,grep("DUF", colnames(PfamData))]
PA_DUFData = DUFData
PA_DUFData[PA_DUFData>1] <- 1 

#---- META DATA --------------
ANVIO_cat = read.table('~/outputtest.txt',header=TRUE,sep="\t")
ANVIO_cat = read.table('~/DATA/MarinobacterGenomics/2018_ProkComp/ANVIO_CAT.txt',header=TRUE,sep="\t")

#---- DEDUPLICATION --------------
DEDUPLICATED =  subset(ANVIO, !duplicated(protein_cluster_id))

#--------------------------------------------------------------------------------------------
#	Load Phylogenetic tree and convert to dendrograms
#--------------------------------------------------------------------------------------------
# Currently, phylogenetic trees are generated outside prokcomp and have to be loaded manually
# In this example we load in RAxML generated newick files, from different matrices
# we include markersets identified by ANVIO, as SCO: single-cop orthologs, Campbell et al, Rinke et al, and ribosomal proteins
# trees are further mod point rooted and ladderized for aesthetic purposes

#load
RAxMLANVIO = read.tree("~/DATA/MarinobacterGenomics/2018_ProkComp/SCO_682_RAxML_bipartitions_autosubst_b100")
RAxMLCampbell = read.tree("~/DATA/MarinobacterGenomics/2018_ProkComp/RAxML_bipartitions.Campbell_AA")
RAxMLRinke = read.tree("~/DATA/MarinobacterGenomics/2018_ProkComp/RAxML_bipartitions.Rinke_AA")
RAxMLRiboProt = read.tree("~/DATA/MarinobacterGenomics/2018_ProkComp/RAxML_bipartitions.Ribosomal_AA")

#Root
RAxMLANVIORooted =  midpoint.root(RAxMLANVIO)
RAxMLCampbellRooted =  midpoint.root(RAxMLCampbell)
RAxMLRinkeRooted =  midpoint.root(RAxMLRinke)
RAxMLRiboProtRooted =  midpoint.root(RAxMLRiboProt)

#increasing branch lengths
tree2 <- ladderize(RAxMLANVIORooted, right = FALSE)
tree3 <- ladderize(RAxMLCampbellRooted, right = FALSE)
tree4 <- ladderize(RAxMLRinkeRooted, right = FALSE)
tree5 <- ladderize(RAxMLRiboProtRooted, right = FALSE)

#can’t have any branch lengths of zero or downstream commands will collapse those nodes…
tree2$edge.length[which(tree2$edge.length == 0)] <- 0.00001
rep_tree_um <- chronopl(tree2,lambda = 0.1,tol = 0)
rep_tree_d <- as.dendrogram(as.hclust.phylo(rep_tree_um))

tree3 $edge.length[which(tree3 $edge.length == 0)] <- 0.00001
rep_tree3_um <- chronopl(tree3,lambda = 0.1,tol = 0)
rep_tree3_d <- as.dendrogram(as.hclust.phylo(rep_tree3_um))

tree4$edge.length[which(tree4$edge.length == 0)] <- 0.00001
rep_tree4_um <- chronopl(tree4,lambda = 0.1,tol = 0)
rep_tree4_d <- as.dendrogram(as.hclust.phylo(rep_tree4_um))

tree5$edge.length[which(tree5$edge.length == 0)] <- 0.00001
rep_tree5_um <- chronopl(tree5,lambda = 0.1,tol = 0)
rep_tree5_d <- as.dendrogram(as.hclust.phylo(rep_tree5_um))


#--------------------------------------------------------------------------------------------
#	Load Phylogenetic tree and convert to dendrograms
#---------------------------------------------------------------------------------------------

#count number of genomes in the dataset
number_of_genomes = length(col(AnvioData))

# number of genomes per PC and Pfam
sums = data.frame(rowSums(AnvioData))
sumsPfam = data.frame(rowSums(PfamData))
colnames(sums) = c('value')
colnames(sumsPfam) = c('value')

#Combine in one dataframe
groupedDistribution = cbind(rbind(sumsPfam,sums),type = c(rep("domain",nrow(sumsPfam)),rep("PC",nrow(sums))))
#groupedDistribution = groupedDistribution[-c(which(groupedDistribution$value == 0)), ]

#Individual plots
ggplot(data=sums, aes(sums$value)) + 
  geom_histogram(bins = 60) + scale_x_continuous(expand = c(0, 0)) + scale_y_continuous(expand = c(0, 0)) + theme_bw() + theme(panel.grid = element_blank(), panel.border = element_blank())
#ggplot(data= sumsPfam, aes(sumsPfam $value)) + 
#  geom_histogram(bins = 60) + scale_x_continuous(expand = c(0, 0)) + scale_y_continuous(expand = c(0, 0)) + theme_bw() + theme(panel.grid = element_blank(), panel.border = element_blank())

o1 = ggplot(data= groupedDistribution, aes(x=value, fill=type)) + 
  geom_histogram(bins = 60,alpha=0.5, position="identity") + scale_x_continuous(expand = c(0, 0)) + scale_y_continuous(expand = c(0, 0)) + theme_bw() + theme(panel.grid = element_blank(), panel.border = element_blank()) +theme(axis.line = element_line(color="black", size = 0.5))
  
#countTable <-table(groupedDistribution$value, groupedDistribution$type)
#dfCount = data.frame(countTable)
#countPC = subset(dfCount ,dfCount$Var2=="PC")
#countDomain = subset(dfCount , dfCount$Var2 =="domain")
#combinedCount = data.frame(cbind(PC=countPC$Freq,Domain=countDomain$Freq))

#o2 = ggplot(data= combinedCount , aes(x=PC, y= Domain)) + geom_point() + scale_y_log10() +  scale_x_log10() + geom_smooth(method="lm",color="darkgreen") + theme_bw() + theme(panel.grid = element_blank(), panel.border = element_blank())+theme(axis.line = element_line(color="black", size = 0.5))

#multiplot(o1,o2,cols=2)

#----------------------------------------------
#	extract accessory genes
#----------------------------------------------

AccesoryDF = PA_AnvioData[!rowSums(PA_AnvioData)==1, ]
AccesoryDF  = AccesoryDF[! rowSums(AccesoryDF)== length(colnames(AccesoryDF)), ]
RareAccesoryDF  = AccesoryDF[!rowSums(AccesoryDF)<7,]
GRareAccesoryDF  = AccesoryDF[!rowSums(AccesoryDF)>10,]
GRareAccesoryDF  = GRareAccesoryDF[!rowSums(GRareAccesoryDF)<2,]

heatmap.2(as.matrix(t(RareAccesoryDF)),trace='none',scale='column',col=colorRampPalette(brewer.pal(9, "RdBu"))(100))
heatmap.2(as.matrix(t(RareAccesoryDF)),trace="none",col = colorRampPalette(brewer.pal(9, "RdGy"))(100),labCol = FALSE,margins = c(2, 20))
heatmap.2(as.matrix(t(RareAccesoryDF)),trace="none",col = c('white','black'),labCol = FALSE,margins = c(2, 20))

AccesoryDF = t(AccesoryDF)
#force row order so that it matches the order of leafs in rep_tree_d
clade_order <- order.dendrogram(rep_tree_d)
clade_name <- labels(rep_tree_d)
clade_position <- data.frame(clade_name,clade_order)
clade_position <- clade_position[order(clade_position$clade_order),]
new_order <- match(clade_position$clade_name, row.names(AccesoryDF))
combined_ordered_matrix <- AccesoryDF[new_order,]

heatmap.2(as.matrix(combined_ordered_matrix),trace="none",col = inferno(75),Rowv= rep_tree_d,labCol = FALSE,margins = c(2, 20),dendrogram="row")




pca.test = cbind(t(RareAccesoryDF),as.factor(ANVIO_cat$group))
Og.pca <- PCA(pca.test, quali.sup= ncol(pca.test),graph = FALSE)
plot(Og.pca , habillage = ncol(pca.test), col.hab = c("green", "blue", "red",'orange','purple'), title = "Dataset projected onto PC1-2 Subspace",cex=2,centre = NULL)


cols = colorRampPalette(brewer.pal(9, "RdYlBu"))(length(unique(ANVIO_cat$group)))
ANVIO_cat $color <- factor(ANVIO_cat$group, labels = cols)
pcacolors <- ANVIO_cat$color
pcacolors <- ANVIO_cat$color

pcacolors2 = pcacolors
names(pcacolors2) = ANVIO_cat$name
pfam_colors = pcacolors2[rownames(PfamData)]

pca3 = panpca(t(RareAccesoryDF), scale = 0)
pca4 = panpca(t(AccesoryDF), scale = 0)
pca5 = panpca(t(AnvioData), scale = 0)
pca6 = panpca((PfamData), scale = 0)
pca7 = panpca((DUFData), scale = 0)



library(rgl)
layout3d(matrix(1:10, 5, 2,byrow = TRUE),sharedMouse = TRUE)
plot3d(pca3$Scores[,1:3], col= pcacolors, size=12, type='p')
grid3d(c("x", "y+", "z"))
next3d()
plot3d(pca3$Scores[,4:6], col= pcacolors, size=12, type='p')
grid3d(c("x", "y+", "z"))
next3d()

plot3d(pca4$Scores[,1:3], col= pcacolors, size=12, type='p')
grid3d(c("x", "y+", "z"))
next3d()
plot3d(pca4$Scores[,4:6], col= pcacolors, size=12, type='p')
grid3d(c("x", "y+", "z"))
next3d()

plot3d(pca5$Scores[,1:3], col= pcacolors, size=12, type='p')
grid3d(c("x", "y+", "z"))
next3d()
plot3d(pca5$Scores[,4:6], col= pcacolors, size=12, type='p')
grid3d(c("x", "y+", "z"))
next3d()

plot3d(pca6$Scores[,1:3], col= pfam_colors, size=12, type='p')
grid3d(c("x", "y+", "z"))
next3d()
plot3d(pca6$Scores[,4:6], col= pfam_colors, size=12, type='p')
grid3d(c("x", "y+", "z"))
next3d()

plot3d(pca7$Scores[,1:3], col= pfam_colors, size=12, type='p')
grid3d(c("x", "y+", "z"))
next3d()
plot3d(pca7$Scores[,4:6], col= pfam_colors, size=12, type='p')
grid3d(c("x", "y+", "z"))


plot3d(pca6$Scores[,1:3], size=12, type='p',col= pfam_colors)



layout3d(matrix(1:4, 2, 2,byrow = TRUE),sharedMouse = TRUE)
plot3d(pca3$Scores[,1:3], col= pcacolors, size=12, type='p')
rgl.viewpoint(theta=-150,phi=25,zoom = 0.9)
grid3d(c("x+", "y", "z+"))
next3d()
plot3d(pca5$Scores[,1:3], col= pcacolors, size=12, type='p')
rgl.viewpoint(theta=-150,phi=25,zoom = 0.9)
grid3d(c("x+", "y", "z+"))
next3d()
plot3d(pca6$Scores[,1:3], col= pfam_colors, size=12, type='p')
rgl.viewpoint(theta=-150,phi=25,zoom = 0.9)
grid3d(c("x+", "y", "z+"))
next3d()
plot3d(pca7$Scores[,1:3], col= pfam_colors, size=12, type='p')
rgl.viewpoint(theta=-150,phi=25,zoom = 0.9)
grid3d(c("x+", "y", "z+"))

rgl.postscript("PCA_rare_access_Pfam_duf.pdf","pdf") 

legend3d("topright", legend = unique(ANVIO_cat$group), pch = 16, col = unique(ANVIO_cat$color), cex=1, inset=c(0.02))


layout3d(matrix(1:1, 1, 1,byrow = TRUE),sharedMouse = TRUE)
plot3d(pca3$Scores[,1:3], col= pcacolors, size=12, type='p')
text3d(pca3$Scores[,1:3],texts=colnames(AnvioData))


layout3d(matrix(1:4, 2, 2,byrow = TRUE),sharedMouse = TRUE)
pca.test = cbind(t(RareAccesoryDF),as.factor(ANVIO_cat$group))
Og.pca <- PCA(pca.test, quali.sup= ncol(pca.test),graph = FALSE)
plot3d(Og.pca$scores[,1:3], col= pcacolors, size=12, type='t')
grid3d(c("x", "y+", "z"))
text3d(Og.pca$Scores[,1:3],texts=rownames(Og.pca))
text3d(Og.pca$Scores[,1], Og.pca $Scores[,2], Og.pca $Scores[,3],texts=c(rownames(Og.pca $Scores)), cex= 0.7, pos=3)
next3d()
plot3d(Og.pca$scores[,4:6], col= pcacolors, size=12, type='p')
grid3d(c("x", "y+", "z"))
next3d()



pca.test = cbind(t(PfamData),as.factor(ANVIO_cat$group))
Og.pca <- PCA(pca.test, quali.sup= ncol(pca.test),graph = FALSE)

plot3d(Og.pca$scores[,1:3], col= pcacolors, size=12, type='p')
grid3d(c("x", "y+", "z"))
next3d()
plot3d(Og.pca$scores[,4:6], col= pcacolors, size=12, type='p')
grid3d(c("x", "y+", "z"))
next3d()

pca.test = cbind(t(DUFData),as.factor(ANVIO_cat$group))
Og.pca <- PCA(pca.test, quali.sup= ncol(pca.test),graph = FALSE)

plot3d(Og.pca$scores[,1:3], col= pcacolors, size=12, type='p')
grid3d(c("x", "y+", "z"))
next3d()
plot3d(Og.pca$scores[,4:6], col= pcacolors, size=12, type='p')
grid3d(c("x", "y+", "z"))
next3d()



#----------------------------------------------
#	Network analysis 
#----------------------------------------------

e = cbind()
for (pc in unique(rownames(GRareAccesoryDF))){
	anviosub = subset(ANVIO, ANVIO$protein_cluster_id == pc)

	for (genome in unique(anviosub$genome_name)){
  		for (genome2 in unique(anviosub$genome_name)){
  			if((genome != genome2) & (nrow(anviosub)<5)){
  				print(c(genome, genome2))
  				e = rbind(e,c(genome, genome2))
			}
		}
	}
}

net = network(e)
net %v% "group" = as.character(x)
ggnet2(net, color = "group", alpha = 0.75, size = 4, edge.alpha = 0.5)

x = data.frame(name = network.vertex.names(net))
x = merge(x, ANVIO_cat, by = "name", sort = FALSE)$group

#----------------------------------------------
#	distribution of unique genes
# sorted like phylogenetic tree! (plot against tree)
#----------------------------------------------

#ANVIO
TotalPCs = rowSums(AnvioData)
Core_count = rowSums(AnvioData[,colSums(AnvioData)== number_of_genomes ])
only_singletons = AnvioData[,colSums(AnvioData)==1 ]
SummaryPanGenome = data.frame(rowSums(only_singletons))
colnames(SummaryPanGenome) = c('Unique')
SummaryPanGenome$name = rownames(SummaryPanGenome)
SummaryPanGenome$Core = Core_count 
SummaryPanGenome$Accessory = rowSums(AnvioData) - SummaryPanGenome$Core - SummaryPanGenome$Unique
SummaryPanGenome$total = SummaryPanGenome$Unique + SummaryPanGenome$Accessory + SummaryPanGenome$Core
#SummaryPanGenome$conserved = SummaryPanGenome$Core / SummaryPanGenome$total 


#Pfam
TotalDomains = rowSums(PfamData)
Core_Pfam_count = rowSums(PfamData[,colSums(PfamData)== number_of_genomes ])
Pfam_singletons = PfamData[,colSums(PfamData)==1 ]
SummaryPfamPanGenome = data.frame(rowSums(Pfam_singletons))
colnames(SummaryPfamPanGenome) = c('Unique')
SummaryPfamPanGenome$name = rownames(SummaryPfamPanGenome)
SummaryPfamPanGenome$Core = Core_Pfam_count 
SummaryPfamPanGenome$Accessory = rowSums(PfamData) - SummaryPfamPanGenome$Core - SummaryPfamPanGenome$Unique


k1 = ggplot(data= SummaryPanGenome, aes(y=SummaryPanGenome$Unique,x=SummaryPanGenome$name)) + geom_col() + xlab("Genome") + ylab("number of unique PCs") + coord_flip() + scale_y_continuous(expand = c(0, 0)) + theme_bw() + theme(panel.grid = element_blank(), panel.border = element_blank())

DF1 <- melt(SummaryPanGenome, id.var="name")

p1 = ggplot(DF1, aes(x = name, y = value, fill = variable)) + 
  geom_bar(stat = "identity") + xlab("Genome") + ylab("Protein Cluster") + coord_flip() + scale_y_continuous(expand = c(0, 0)) + theme_bw() + theme(panel.grid = element_blank(), panel.border = element_blank())
ggplot(subset(DF1,variable!='Core'), aes(x = variable, y = value)) + geom_boxplot() + xlab("pan-genome devision") + ylab("number of PCs") + scale_y_continuous(expand = c(0, 0)) + theme_bw() + theme(panel.grid = element_blank(), panel.border = element_blank()) + geom_hline(yintercept = unique(Core_count),linetype = 2) + theme_classic()


#----------------------------------------------
#	Polar_histogram using PhenotypicForest package
#----------------------------------------------

DF3 = DF1[DF1$variable!='total',]
names(DF3)=c('name','score','value')
DF4 = right_join(DF3, ANVIO_cat,by=('name'))
DF5 = data.frame(family=DF4$group,item=DF4$name,score=DF4$score,value=DF4$value)

polarHistogram(DF5, familyLabel = TRUE,guides=c(25,50,75),alphaStart=-1.56,circleProportion=0.50)

#----------------------------------------------
#	distribution of unique genes
# sorted like phylogenetic tree! (plot against tree)
#----------------------------------------------
algn  = read.alignment('~/DATA/MarinobacterGenomics/2018_ProkComp/concatenated_CORE_AA.fa', format = "fasta")
algn2 = as.phyDat(algn,type="AA")

dm  <- dist.ml(algn2)
treeUPGMA  <- upgma(dm)
treeNJ  <- NJ(dm)
treeNJRooted =  midpoint.root(treeNJ)
#increasing branch lengths
treeNJRooted_sorted1 <- ladderize(treeNJRooted, right = FALSE)
plot(treeNJRooted_sorted1, main='concatenated_core')
#plot(treeNJRooted_sorted, 'unrooted', main=i)

algn  = read.alignment('~/DATA/MarinobacterGenomics/2018_ProkComp/concatenated_Campbell_AA.fa', format = "fasta")
algn2 = as.phyDat(algn,type="AA")

dm  <- dist.ml(algn2)
treeUPGMA  <- upgma(dm)
treeNJ  <- NJ(dm)
treeNJRooted =  midpoint.root(treeNJ)
#increasing branch lengths
treeNJRooted_sorted2 <- ladderize(treeNJRooted, right = FALSE)
plot(treeNJRooted_sorted2, main='Campbell')
#plot(treeNJRooted_sorted, 'unrooted', main=i)

algn  = read.alignment('~/DATA/MarinobacterGenomics/2018_ProkComp/concatenated_Rinke_AA.fa', format = "fasta")
algn2 = as.phyDat(algn,type="AA")

dm  <- dist.ml(algn2)
treeUPGMA  <- upgma(dm)
treeNJ  <- NJ(dm)
treeNJRooted =  midpoint.root(treeNJ)
#increasing branch lengths
treeNJRooted_sorted3 <- ladderize(treeNJRooted, right = FALSE)
plot(treeNJRooted_sorted3, main='Rinke')
#plot(treeNJRooted_sorted, 'unrooted', main=i)


nrofGenomes = length(unique(ANVIO$genome_name))

CheckM = read.table("~/DATA/MarinobacterGenomics/2018_ProkComp/qa2.txt",header=TRUE,sep="\t")
CheckM2 = subset(CheckM, Completeness > 98)
CheckM2 = subset(CheckM2, Contamination < 0.5)

ggplot(CheckM2, aes(x=Genome_size, y=predicted_genes))+geom_point(size=CheckM2$Contamination) + geom_smooth(method='lm',size=0.5,color='black')

TotalPCs = rowSums(AnvioData)
Core_count = rowSums(AnvioData[,colSums(AnvioData)==71 ])
only_singletons = AnvioData[,colSums(AnvioData)==1 ]
SummaryPanGenome = data.frame(rowSums(only_singletons))
colnames(SummaryPanGenome) = c('Unique')
SummaryPanGenome$name = rownames(SummaryPanGenome)
SummaryPanGenome$Core = Core_count 
SummaryPanGenome$Accessory = rowSums(AnvioData) - SummaryPanGenome$Core - SummaryPanGenome$Unique
SummaryPanGenome$total = SummaryPanGenome$Unique + SummaryPanGenome$Accessory + SummaryPanGenome$Core
SummaryPanGenome$conserved = SummaryPanGenome$Core / SummaryPanGenome$total 


k1 = ggplot(data= SummaryPanGenome, aes(y=SummaryPanGenome$Unique,x=SummaryPanGenome$name)) + geom_col() + xlab("Genome") + ylab("number of unique PCs") + coord_flip() + scale_y_continuous(expand = c(0, 0)) + theme_bw() + theme(panel.grid = element_blank(), panel.border = element_blank())

multiplot(k1, k2,cols=2)

DF1 <- melt(SummaryPanGenome, id.var="name")
p1 = ggplot(DF1, aes(x = name, y = value, fill = variable)) + 
  geom_bar(stat = "identity") + xlab("Genome") + ylab("Protein Cluster") + coord_flip() + scale_y_continuous(expand = c(0, 0)) + theme_bw() + theme(panel.grid = element_blank(), panel.border = element_blank())


#######################################

sp <- specaccum(AnvioData, 'random', permutations=100)
Pfam_sp <- specaccum(PfamData, 'random', permutations=100)

binomix2 <- binomixEstimate(AnvioData, K.range=2:15)

summary(binomix2)

summary(sp)
plot(sp, ci.type='poly', col='darkred', lwd=2, ci.lty=0, ci.col='darkred', xlab='Genomes', ylab='Proteins', main='Gene accumulation plot')
boxplot(sp, col='white', add=TRUE,cex=0.5,pch = 21) 
boxplot(Pfam_sp, col='darkgrey', add=TRUE,cex=0.5,pch = 21) 

mods <- fitspecaccum(sp, "arrh")
plot(mods, col="grey",,xlab='Genomes', ylab='Protein Clusters', main='Gene accumulation plot')
boxplot(sp, col = "white", border = "black", lty=1, cex=0.3, add= TRUE)
## Use nls() methods to the list of models
sapply(mods$models, AIC)

plot(sp, ci.type='poly', col='black', lwd=2, ci.lty=0, ci.col='lightskyblue3', xlab='Genomes', ylab='Proteins', main='accumulation plot')
boxplot(sp, col = "white", border = "darkblue", lty=1, cex=0.3, add= TRUE)
par(new = T)
plot(Pfam_sp, ci.type='poly', col='black', lwd=2, ci.lty=0, ci.col='pink', axes=F, xlab=NA, ylab=NA)
boxplot(Pfam_sp, col = "white", border = "darkred", lty=1, cex=0.3, add= TRUE)
axis(side = 4)
mtext(side = 4, line = 3, 'PfamDomains')

#######################################

mods <- fitspecaccum(sp, "arrh")
plot(mods, col="grey",,xlab='Genomes', ylab='Protein Clusters', main='Gene accumulation plot')

## Use nls() methods to the list of models
sapply(mods$models, AIC)

plot(sp, ci.type='poly', col='black', lwd=2, ci.lty=0, ci.col='lightskyblue3', xlab='Genomes', ylab='Proteins', main='accumulation plot')
boxplot(sp, col = "white", border = "darkblue", lty=1, cex=0.3, add= TRUE)

#---- sopen or closed panGENOME --------------
# Estimating if the pan-genome is open or closed based on a Heaps law model
#This function is based on a Heaps law approach suggested by Tettelin et al (2008). The Heaps law model is fitted to the number of new gene clusters observed when genomes are ordered in a random way. The model has two parameters, an intercept and a decay parameter called alpha. If alpha>1.0 the pan-genome is closed, if alpha<1.0< span=""> it is open.
#----------------------------------------------

heaps(AnvioData,n.perm=100)
heaps(PfamData,n.perm=100)

#---- Pan-genome size --------------
#Chao - computes the Choa lower bound estimated number of gene clusters in a pan-genome

chao.PCsize <- chao(AnvioData)
chao.Pfampansize <- chao(PfamData)

#---- Binomial mixture model --------------

binomix <- binomixEstimate(AnvioData, K.range=2:15)
binomix2 <- binomixEstimate(PfamData, K.range=2:15)

# Displaying the BIC.table
binomix$BIC.table
binomix2$BIC.table

# Summary of model
summary(binomix)
summary(binomix2)



#####################################################################################################################
#
#		Distance based approches
#
#####################################################################################################################



result = pvclust(AnvioData, method.dist="cor", method.hclust="ward.D2", nboot=1000)


#---- DISTANCES AND WEIGHTED DISTANCES --------------
#Manhattan and/or Jaccard distances between pan-genome profiles. Jaccard distance is based on similarity of shared genes, while Manhattan distance also includes similarity of lacking a certain gene (which is often recommended).(Snipen and Ussery, 2010)
#----------------------------------------------

#Jaccard distances based on panmatrix
Jdist.blast <- distJaccard(AnvioData)
Jdist.blast.pfam <- distJaccard(PfamData)

#manhatten distamces 
Mdist.blast <- distManhattan(AnvioData)
Mdist.blast.pfam <- distManhattan(PfamData)

#fluidityy
fluid.blast <- fluidity(AnvioData)
fluid.blast.pfam <- fluidity(PfamData)


#----------------------------------------------
#	Following weighting function computes weights for gene cluster according to their distribution in a pan-genome. 
#	When computing distances between genomes or a PCA, it is possible to give weights to the different gene clusters, emphasizing certain aspects. 
#	As proposed by Snipen & Ussery (2010), we have implemented two types of weighting: The default ‘"shell"’ type means gene families occuring 	frequently in the genomes, denoted shell-genes, are given large weight (close to 1) while those occurring rarely are given small weight (close to 0). The opposite is the ‘"cloud"’ type of weighting. Genes observed in a minority of the genomes are referred to as cloud-genes. Presumeably, the ‘"shell"’ weighting will give distances/PCA reflecting a more long-term evolution, since emphasis is put on genes who have just barely diverged away from the core. The ‘"cloud"’ weighting emphasizes those gene clusters seen rarely. Genomes with similar patterns among these genes may have common recent history. A ‘"cloud"’ weighting typically gives a more erratic or ‘noisy’ picture than the ‘"shell"’ weighting. 
#----------------------------------------------

PAPfamData = PfamData
PAPfamData[PAPfamData>1] <- 1 

w <- geneWeights(PfamData,type="shell")
w2 <- geneWeights(PfamData,type="cloud")
v <- geneWeights(PAPfamData,type="shell")
v2 <- geneWeights(PAPfamData,type="cloud")

Mdist.blast <- distManhattan(PfamData)
Jdist.blast <- distJaccard(PfamData)
Mdist1.blast <- distManhattan(PfamData,weights=w)
Mdist2.blast <- distManhattan(PfamData,weights=w2)

PAMdist.blast <- distManhattan(PAPfamData)
PAJdist.blast <- distJaccard(PAPfamData)
PAMdist1.blast <- distManhattan(PAPfamData,weights=w)
PAMdist2.blast <- distManhattan(PAPfamData,weights=w2)

m2 <- melt(as.matrix(Mdist.blast))[melt(upper.tri(as.matrix(Mdist.blast)))$value,]
m3 <- melt(as.matrix(Jdist.blast))[melt(upper.tri(as.matrix(Jdist.blast)))$value,]
m4 <- melt(as.matrix(Mdist1.blast))[melt(upper.tri(as.matrix(Mdist1.blast)))$value,]
m5 <- melt(as.matrix(Mdist2.blast))[melt(upper.tri(as.matrix(Mdist2.blast)))$value,]

m6 <- melt(as.matrix(PAMdist.blast))[melt(upper.tri(as.matrix(PAMdist.blast)))$value,]
m7 <- melt(as.matrix(PAJdist.blast))[melt(upper.tri(as.matrix(PAJdist.blast)))$value,]
m8 <- melt(as.matrix(PAMdist1.blast))[melt(upper.tri(as.matrix(PAMdist1.blast)))$value,]
m9 <- melt(as.matrix(PAMdist2.blast))[melt(upper.tri(as.matrix(PAMdist2.blast)))$value,]


constructedMatrix = data.frame(cbind(m2$value,m3$value,m4$value,m5$value,m6$value,m7$value,m8$value,m9$value))
colnames(constructedMatrix) = c("Manthattan_UW","Jaccard_UW","Manthattan_SW","Manthattan_CW","PA_Manthattan_UW","PA_Jaccard_UW","PA_Manthattan_SW","PA_Manthattan_CW")

q1 = ggplot(constructedMatrix, aes(Manthattan_UW, Jaccard_UW)) + geom_point() + geom_smooth(method="nls", formula=y~SSasymp(x, Asym, R0, lrc), color="red", se=F, fullrange=T) + theme_classic()
q2 = ggplot(constructedMatrix, aes(Manthattan_UW, Manthattan_SW)) + geom_point() + theme_classic()
 #+ geom_smooth(method="nls", formula=y~SSasymp(x, Asym, R0, lrc), color="red", se=F, fullrange=T) 
q3 = ggplot(constructedMatrix, aes(Manthattan_UW, Manthattan_CW)) + geom_point() + theme_classic()
q4 = ggplot(constructedMatrix, aes(PA_Manthattan_UW, PA_Jaccard_UW)) + geom_point() + geom_smooth(method="nls", formula=y~SSasymp(x, Asym, R0, lrc), color="red", se=F, fullrange=T) + theme_classic()
q5 = ggplot(constructedMatrix, aes(PA_Manthattan_UW, PA_Manthattan_SW)) + geom_point() + theme_classic()
 #+ geom_smooth(method="nls", formula=y~SSasymp(x, Asym, R0, lrc), color="red", se=F, fullrange=T) 
q6 = ggplot(constructedMatrix, aes(PA_Manthattan_UW, PA_Manthattan_CW)) + geom_point() + theme_classic()

q7 = ggplot(constructedMatrix, aes(Manthattan_UW,PA_Manthattan_UW)) + geom_point() + geom_smooth(method="nls", formula=y~SSasymp(x, Asym, R0, lrc), color="red", se=F, fullrange=T) + theme_classic()
q8 = ggplot(constructedMatrix, aes(Manthattan_SW, PA_Manthattan_SW)) + geom_point() + theme_classic()
 #+ geom_smooth(method="nls", formula=y~SSasymp(x, Asym, R0, lrc), color="red", se=F, fullrange=T) 
q9 = ggplot(constructedMatrix, aes(Manthattan_CW, PA_Manthattan_CW)) + geom_point() + theme_classic()


multiplot(q1,q4,q7,q2,q5,q8,q3,q6,q9,cols=3)

# # Based on these results, we can reject the null hypothesis that these two matrices, spatial distance and ozone distance, are unrelated with alpha = .05. The observed correlation, r = 0.1636308, suggests that the matrix entries are positively associated.  So smaller differences in ozone are generally seen among pairs of stations that are close to each other than far from each other. Note that since this test is based on random permutations, the same code will always arrive at the same observed correlation but rarely the same p-value.
mantel.rtest(Mdist.blast, Jdist.blast, nrepet = 999)


#####################################################################################################################
#
#		PAN TREES
#
#####################################################################################################################

#---- Calculate so called PAN-trees --------------


ANVIOtree <- panTree(AnvioData,nboot=100)
PA_ANVIOtree <- panTree(PA_AnvioData,nboot=100)
Pfamtree <- panTree(PfamData,nboot=100)
PAPfamtree <- panTree(PAPfamData,nboot=100)
DUFtree <- panTree(DUFData,nboot=100)
PADUFtree <- panTree(PA_DUFData,nboot=100)


#---- neighborNet as split network function --------------
nnet <- neighborNet(Mdist.blast)

#---- neighborNet as split network function --------------


par(mfrow=c(3,2)) 
plot(as.phylo(ANVIOtree $Htree),type="unrooted",no.margin = TRUE,cex=0.3,main='PC abundance')
plot(as.phylo(PA_ANVIOtree$Htree),type="unrooted",no.margin = TRUE,cex=0.3,main='PC PresAbs')
plot(as.phylo(Pfamtree$Htree),type="unrooted",no.margin = TRUE,cex=0.3,main='Domain abundance')
plot(as.phylo(PAPfamtree$Htree),type="unrooted",no.margin = TRUE,cex=0.3,main='Domain PresAbs')
plot(as.phylo(DUFtree$Htree),type="unrooted",no.margin = TRUE,cex=0.3,main='DUF abundance')
plot(as.phylo(PADUFtree $Htree),type="unrooted",no.margin = TRUE,cex=0.3,main='DUF PresAbs')


par(mfrow=c(1,6)) 
plot(ANVIOtree,xlab="Protein Clusters (abundance)",cex=0.75)
plot(PA_ANVIOtree,xlab="Protein Clusters (presence.absence)",cex=0.75)
plot(Pfamtree,xlab="Pfamtree",cex=0.75)
plot(PAPfamtree,xlab="PAPfamtree",cex=0.75)
plot(DUFtree,xlab="DUFPfamtree",cex=0.75)
plot(PADUFtree,xlab="PADUFPfamtree",cex=0.75)


w <- geneWeights(PfamData,type="shell")
v <- geneWeights(PAPfamData,type="shell")

wPfamtree = panTree(Pfamtree, weights=w,nboot = 100)
wPAPfamData = panTree(PAPfamData, weights=v,nboot = 100)

par(mfrow=c(1,2)) 
plot(tree2)
plot(wPfamtree,xlab="weighted Pfam Mantattan distance")
plot(wPAPfamData,xlab="weighted PAPfam domains Mantattan distance")
tanglegram(as.dendrogram(PAPfamtree$Htree),as.dendrogram(wPAPfamData $Htree))
tanglegram(as.dendrogram(PAPfamtree$Htree),as.dendrogram(DUFtree $Htree))

library(ape)
library(phytools)


Phylophlan = read.tree("~/DATA/MarinobacterGenomics/miscl/Oceano_clean.tree.nwk")

PhylophlanRooted =  midpoint.root(Phylophlan)

tree2 <- ladderize(PhylophlanRooted, right = FALSE)

tr = plot(tree2)

is_tip <- tree2$edge[,2] <= length(tree2$tip.label)
ordered_tips <- tree2$edge[is_tip, 2]
tree2$tip.label[ordered_tips]

library(DECIPHER)


force.ultrametric<-function(tree,method=c("nnls","extend")){
    method<-method[1]
    if(method=="nnls") tree<-nnls.tree(cophenetic(tree),tree,
        rooted=TRUE,trace=0)
    else if(method=="extend"){
        h<-diag(vcv(tree))
        d<-max(h)-h
        ii<-sapply(1:Ntip(tree),function(x,y) which(y==x),
            y=tree$edge[,2])
        tree$edge.length[ii]<-tree$edge.length[ii]+d
    } else 
        cat("method not recognized: returning input tree\n\n")
    tree
}

ult.nnls<-force.ultrametric(tree2)
tanglegram(ladderize(ult.nnls, right = FALSE), ladder(as.dendrogram(PAPfamtree$Htree), decreasing = TRUE))

PhyloDistMatrix<-cophenetic(tree2)
PhyloDistMatrix = PhyloDistMatrix[-grep("Marinicella_sp", rownames(PhyloDistMatrix)),-grep("Marinicella_sp", colnames(PhyloDistMatrix))]
PfamDist=dist(PfamData)
PfamDist  = PfamDist[ order(row.names(PfamDist)), ]
PfamDist  = PfamDist[ , order(colnames(PfamDist))]
DUFdist = distManhattan(DUFData)
PhyloDistMatrix  = PhyloDistMatrix[ order(row.names(PhyloDistMatrix)), ]
PhyloDistMatrix  = PhyloDistMatrix[ , order(colnames(PhyloDistMatrix))]
Mdist.blast = Mdist.blast[ , order(colnames(Mdist.blast))]
Jdist.blast = Jdist.blast[ , order(colnames(Jdist.blast))]
AAI  = AAI[ , order(colnames(AAI))]
AAI  = AAI[ order(row.names(AAI)), ]
OF  = OF[ , order(colnames(OF))]
OF  = OF[ order(row.names(OF)), ]
Og  = Og[ , order(colnames(Og))]
Og  = Og[ order(row.names(Og)), ]
#distTips(tree)
Mdist.blast
m2 <- melt(as.matrix(PfamDist))[melt(upper.tri(as.matrix(PfamDist)))$value,]
m3 <- melt(as.matrix(PhyloDistMatrix))[melt(upper.tri(as.matrix(PhyloDistMatrix)))$value,]
m4 <- melt(as.matrix(Mdist.blast))[melt(upper.tri(as.matrix(Mdist.blast)))$value,]
m5 <- melt(as.matrix(Jdist.blast))[melt(upper.tri(as.matrix(Jdist.blast)))$value,]
#m6 <- melt(as.matrix(PAJdist.blast))[melt(upper.tri(as.matrix(PAJdist.blast)))$value,]
m7 <- melt(as.matrix(DUFdist))[melt(upper.tri(as.matrix(DUFdist)))$value,]
m8=melt(as.matrix(AAI))[melt(upper.tri(as.matrix(AAI)))$value,]
m10 = melt(as.matrix(OF))[melt(upper.tri(as.matrix(OF)))$value,]
m11 = melt(as.matrix(Og))[melt(upper.tri(as.matrix(Og)))$value,]


DUFdist

constructedMatrix = data.frame(cbind(m2$value,m3$value,m4$value,m5$value,m7$value,m8$value,m10$value,m11$value))
colnames(constructedMatrix) = c("Pfam","phylogeny","PfamManhat",'JaccardPfam','DUFdist','AAI','Orthologous_fraction','nr_of_orthologs')

g1 = ggplot(constructedMatrix, aes(phylogeny, Pfam)) + geom_point(size=0.3) + geom_smooth(method="nls", formula=y~SSasymp(x, Asym, R0, lrc), color="red", se=F, fullrange=T)  +  geom_smooth(color="lightgrey", se=F, fullrange=T) + theme_classic()
g2 = ggplot(constructedMatrix, aes(phylogeny, PfamManhat)) + geom_point(size=0.3) + geom_smooth(method="nls", formula=y~SSasymp(x, Asym, R0, lrc), color="red", se=F, fullrange=T)  +  geom_smooth(color="lightgrey", se=F, fullrange=T) + theme_classic()
g3 = ggplot(constructedMatrix, aes(phylogeny, JaccardPfam)) + geom_point(size=0.3) + geom_smooth(method="nls", formula=y~SSasymp(x, Asym, R0, lrc), color="red", se=F, fullrange=T)  +  geom_smooth(color="lightgrey", se=F, fullrange=T) + theme_classic()
g5 = ggplot(constructedMatrix, aes(phylogeny, DUFdist)) + geom_point(size=0.3) + geom_smooth(method="nls", formula=y~SSasymp(x, Asym, R0, lrc), color="red", se=F, fullrange=T) +  geom_smooth(color="lightgrey", se=F, fullrange=T) + theme_classic()
g6 = ggplot(constructedMatrix, aes(phylogeny, 100-AAI)) + geom_point(size=0.3) + geom_smooth(method="nls", formula=y~SSasymp(x, Asym, R0, lrc), color="red", se=F, fullrange=T) +  geom_smooth(color="lightgrey", se=F, fullrange=T) + theme_classic()
multiplot(g6,g1,g2,g3,g5,cols=2)
g8 = ggplot(constructedMatrix, aes(PfamManhat, DUFdist)) + geom_point(size=0.3) + geom_smooth(method="lm", color="red", se=F, fullrange=T) +  geom_smooth(color="lightgrey", se=F, fullrange=T) + theme_classic()
g7 = ggplot(constructedMatrix, aes(phylogeny, 100-Orthologous_fraction)) + geom_point(size=0.3) + geom_smooth(method="nls", formula=y~SSasymp(x, Asym, R0, lrc), color="red", se=F, fullrange=T) +  geom_smooth(color="lightgrey", se=F, fullrange=T) + theme_classic()
g82 = ggplot(constructedMatrix, aes(phylogeny, nr_of_orthologs)) + geom_point(size=0.3) + geom_smooth(method="nls", formula=y~SSasymp(x, Asym, R0, lrc), color="red", se=F, fullrange=T) +  geom_smooth(color="lightgrey", se=F, fullrange=T) + theme_classic()
g9 = ggplot(constructedMatrix, aes(100-AAI, nr_of_orthologs)) + geom_point(size=0.3) + geom_smooth(method="lm", color="red", se=F, fullrange=T) +  geom_smooth(color="lightgrey", se=F, fullrange=T) + theme_classic()
g10 = ggplot(constructedMatrix, aes(AAI, Orthologous_fraction)) + geom_point(size=0.3) + geom_smooth(method="lm", color="red", se=F, fullrange=T) +  geom_smooth(color="lightgrey", se=F, fullrange=T) + theme_classic()
g11 = ggplot(constructedMatrix, aes(AAI, nr_of_orthologs)) + geom_point(size=0.3) + geom_smooth(method="lm", color="red", se=F, fullrange=T) +  geom_smooth(color="lightgrey", se=F, fullrange=T) + theme_classic()

mantel.rtest(PhyloDistMatrix, PfamDist, nrepet = 999)

multiplot(g6,g1,g3,g2,g5,g7,g8,g9, g82,g10,g11,cols=3)




