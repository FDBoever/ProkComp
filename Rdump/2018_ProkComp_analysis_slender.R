####################################################################################################################################################
#	Developed by Frederik De Boever	
#	Last Edited: 02-03-2018
#
#	DOWNSTREAM PANGENOME ANALYSIS AS PART OF PROKCOMP
#	you will have to wait for a full description
#
####################################################################################################################################################

#--------------------------------------------------------------------------------------------
#	Dependencies
#--------------------------------------------------------------------------------------------

library(vegan)
library(seqinr)
library(phangorn)
library(phytools)
library(phenotypicForest)
library(ggpubr)
library(phylolm)
library("ggtree")
library(plyr)
library(ggplot2)
library(viridis)
library(devtools)
library(dplyr)
library(reshape)
library(micropan)
library(ade4)
library(dendextend)
library(pvclust)
library(rgl)
library(factominer)
library(gplots)
library(RColorBrewer)
library(FactoMineR)
library(ggplot2)
library(Hmisc)
library(cowplot)

#--------------------------------------------------------------------------------------------
#	Load PANGENOME DATA 
#--------------------------------------------------------------------------------------------
# This section will import data generated by ANVIO and PfamScan, and will modulate them to fit further analysis
# Raw datafiles will be split into either abundance and presence/absence matrices, which will be used lateron 
# additionally, we load-in a tab-deliminted file that categorises the genomes, any category is possible
# for convenience in later merging of dataframes, we deduplicate the ANVIO_protein_clusters_summary.txt to only have one record per PC
# we also extract all DUF domains, and construct a seperate set of abundance and presence/Absence datafiles

# !!!!! PLEASE MAKE SURE YOU DIRECT TO YOUR LOCAL FILES BY CHANGING THE PATHS !!!!!!


#---- ANVIO data --------------
ANVIO <- read.table('~/DATA/MarinobacterGenomics/2018_ProkComp/MARINOBACTER_protein_clusters_summary.txt',header=TRUE,sep="\t") #protein clusters
ANVIO $COG_FUNCTION = sub('\\\t.*', '', ANVIO$COG_FUNCTION)

AnvioData <-table(ANVIO $genome_name, ANVIO $protein_cluster_id)
AnvioData = t(AnvioData)
PA_AnvioData = AnvioData
PA_AnvioData[PA_AnvioData>1] <- 1 

#---- PFAM data --------------
PfamData <- read.table('~/DATA/MarinobacterGenomics/2018_ProkComp/PfamScan_output.csv',header=TRUE,sep='\t')
PfamData = table(PfamData$genome, PfamData$domain)
PAPfamData = PfamData
PAPfamData[PAPfamData>1] <- 1 

#---- PFAM data --------------
#generate a dataframe that contains only the DUF domains 
DUFData = PfamData[,grep("DUF", colnames(PfamData))]
PA_DUFData = DUFData
PA_DUFData[PA_DUFData>1] <- 1 

#---- META DATA --------------
#ANVIO_cat = read.table('~/outputtest.txt',header=TRUE,sep="\t")
ANVIO_cat = read.table('~/DATA/MarinobacterGenomics/2018_ProkComp/ANVIO_CAT.txt',header=TRUE,sep="\t")

#---- DEDUPLICATION --------------
DEDUPLICATED =  subset(ANVIO, !duplicated(protein_cluster_id))


#########################################
#	COLORS
#########################################

#---- MANUALLY ADD COLORS AS YOU PLEASE --------------
# assess the grouping factor in the ANVIO_cat file and sort the colors on the basis of 
# levels(ANVIO_cat_restricted$group2)

colors = c(
rgb(57,129,29, maxColorValue=255),#adhaerens
rgb(134,218,129, maxColorValue=255),#alg
rgb(166,216,212, maxColorValue=255),#ant
rgb(242,169,104, maxColorValue=255),#ex

rgb(242,236,112, maxColorValue=255), #hydrocarb
rgb(227,143,221, maxColorValue=255),#lipo

rgb(137,137,137, maxColorValue=255),#other
rgb(118,174,207, maxColorValue=255),#psych
rgb(131,115,27, maxColorValue=255),#sedim
rgb(179,77,34, maxColorValue=255)#vinifirmus
)

Habitat_colors = c('gray',"#E41A1C","#F37912","#FFD422","#43997A","#658E67","#5D6795","#A35390","#B85F49")


#--------------------------------------------------------------------------------------------
#	QUALITY CONTROL and DATA FILTERING
#--------------------------------------------------------------------------------------------
# To make sure we only continue further analysis using genomes of sufficient quality, we have a look at different QC measures
# Currently automated to test different stringency filters using various cut-offs (tweak arround where you see fit)
# CheckM statistics are derived from the CheckM output file 'qa2.txt' 
# ANVIO based quality statistics can be derived from the ANVIO output file [PROJECT-NAME]-samples-information.txt
# BUSCO summary file ([PROJECT-NAME]_BUSCO_SUMMARY.txt) is generated by ProkComp and can be found in BUSCO_output folder  

# Loading the files, make sure you chance to the approproate paths
CheckM = read.table('~/DATA/MarinobacterGenomics/2018_ProkComp/qa2.txt',header=TRUE,sep="\t")
ANVIOcheck = read.table("~/DATA/MarinobacterGenomics/2018_ProkComp/MARINOBACTER-samples-information.txt",header=TRUE)
BUSCOcheck = read.table("~/DATA/MarinobacterGenomics/2018_ProkComp/Marinobacter_BUSCO_SUMMARY.txt",header = TRUE)


# For merging the files on the basis of genome name, we ought to make sure that columns containing  genome_names are called in te same way.
# In this case, we standardize the column to 'Bin_Id', inspired by CheckM
colnames(ANVIOcheck)=c('Bin_Id','total_length','percent_completion','percent_redundancy','gc_content','num_genes','avg_gene_length','num_genes_per_kb')
colnames(BUSCOcheck)=c('Bin_Id','S','D','F','M')
CheckM$N50 = as.numeric(as.character(CheckM$N50))


# CheckM and ANVIO statistics based filtering
#--------------------------------------------------------------------------------------------

# CheckM stringency filters
# CheckM = all genomes analysed by CheckM
# CheckM2 = all genomes passing the Completeness > 98, Contamination < 5 filter (high stringency)
# CheckM3 = all genomes passing the Completeness > 99, Contamination < 1 filter (very high stringency)
# CheckM4 = all genomes passing the Completeness = 100, Contamination = 0 filter (maximum stringency)

CheckM2 = subset(CheckM, Completeness > 98)					# CheckM estimated Completeness > 98
CheckM2 = subset(CheckM2, Contamination < 5)				# CheckM estimated Contamination < 5
CheckM3 = subset(CheckM2, Completeness > 99)				# CheckM estimated Completeness > 99
CheckM3 = subset(CheckM3, Contamination < 1)				# CheckM estimated Contamination < 1
CheckM4 = subset(CheckM3, Completeness ==100)				# CheckM estimated Completeness = 100
CheckM4 = subset(CheckM4, Contamination == 0)				# CheckM estimated Contamination = 0


# The dataframe [CheckMANVIO2] generated here combines CheckM and ANVIO based quality filtering
# It only includes genomes with [CheckM] Completeness > 99; Contamination < 1 and [ANVIO] percent_completion > 98, percent_redundancy < 10

CheckMANVIO = right_join(CheckM, ANVIOcheck, by=c('Bin_Id'))

# CheckANVIO2 = all genomes passing the stringent CHECKM QC and additional > 98 % completion according to ANVIO
# and additional < 10 % redundancy according to ANVIO
CheckMANVIO2 = subset(CheckMANVIO, percent_completion > 98) 		# ANVIO based "high_stringency"
CheckMANVIO2 = subset(CheckMANVIO2, percent_redundancy < 10) 		# ANVIO based "high_stringency"
CheckMANVIO2 = subset(CheckMANVIO2, Completeness > 99)  			# CheckM based "very_high_stringency"
CheckMANVIO2 = subset(CheckMANVIO2, Contamination < 1)  			# CheckM based "very_high_stringency"


# Restricted ANVIO_CAT on the basis of quality filtering
ANVIO_cat_restricted = ANVIO_cat
rownames(ANVIO_cat_restricted) = ANVIO_cat_restricted $name
ANVIO_cat_restricted = ANVIO_cat_restricted[CheckMANVIO2$Bin_Id,]

# Generate a color vector used to denote clades coloration
cladecolors = as.character(factor(ANVIO_cat_restricted$group2, labels = colors))



# Visualisation STEP: explore the result tables graphically, as an example we show the distrubution of the summary statistics for all analysed genomes (CheckM)
#--------------------------------------------------------------------------------------------------------------------------------------------------------------

CheckM_interest = CheckM[,c('Bin_Id','Completeness','Contamination','Strain_heterogeneity','Genome_size','ambiguous_bases','scaffolds','contigs','N50','N50contigs','Mean_scaffold_length','GC','GC_std','Coding_density','predicted_genes')]
moltenCheckM = melt(CheckM_interest)

ggboxplot(moltenCheckM, x = "variable",
          y = c("value"),
          combine = TRUE,
          add = "jitter",                              # Add jittered points
          add.params = list(size = 0.1, jitter = 0.2)  # Point size and the amount of jittering
          ) + facet_wrap(~variable,scales='free')

CheckMANVIO2_interest = CheckMANVIO2[,c('Bin_Id','Completeness','Contamination','Strain_heterogeneity','Genome_size','ambiguous_bases','scaffolds','contigs','N50','N50contigs','Mean_scaffold_length','GC','GC_std','Coding_density','predicted_genes')]
moltenCheckMANVIO2 = melt(CheckMANVIO2_interest)

ggboxplot(moltenCheckMANVIO2, x = "variable",
          y = c("value"),
          combine = TRUE,
          add = "jitter",                              # Add jittered points
          add.params = list(size = 0.1, jitter = 0.2)  # Point size and the amount of jittering
          ) + facet_wrap(~variable,scales='free')


# STEP ONE: explore the result tables graphically, as an example we show the distrubution of the summary statistics for all analysed genomes (CheckM)
#--------------------------------------------------------------------------------------------------------------------------------------------------------------
# Rememver, we made several dataframes with different cut-offs
# CheckM = all genomes analysed by CheckM
# CheckM2 = all genomes passing the Completeness > 98, Contamination < 5 filter (high stringency)
# CheckM3 = all genomes passing the Completeness > 99, Contamination < 1 filter (very high stringency)
# CheckM4 = all genomes passing the Completeness = 100, Contamination = 0 filter (maximum stringency)

#Basic exploration
g1 = gghistogram(CheckM, x = "Completeness", add = "mean", rug = TRUE,bins=100,color="darkred")
g2 = gghistogram(CheckM, x = "Contamination", add = "mean", rug = TRUE,bins=100,color="darkred")
g3 = gghistogram(CheckM, x = "Strain_heterogeneity", add = "mean", rug = TRUE,bins=100,color="darkred")
v1 = gghistogram(data.frame(CheckM), x = "N50", add = "mean", rug = TRUE,bins=100,color="darkred")
v2 = gghistogram(data.frame(CheckM), x = "scaffolds", add = "mean", rug = TRUE,bins=100,color="darkred")
g4 = gghistogram(CheckM2, x = "Completeness", add = "mean", rug = TRUE,bins=100,color="darkred")
g5 = gghistogram(CheckM2, x = "Contamination", add = "mean", rug = TRUE,bins=100,color="darkred")
g6 = gghistogram(CheckM2, x = "Strain_heterogeneity", add = "mean", rug = TRUE,bins=100,color="darkred")
v3 = gghistogram(data.frame(CheckM2), x = "N50", add = "mean", rug = TRUE,bins=100,color="darkred")
v4 = gghistogram(data.frame(CheckM2), x = "scaffolds", add = "mean", rug = TRUE,bins=100,color="darkred")
g7 = gghistogram(CheckM3, x = "Completeness", add = "mean", rug = TRUE,bins=100,color="darkred")
g8 = gghistogram(CheckM3, x = "Contamination", add = "mean", rug = TRUE,bins=100,color="darkred")
g9 = gghistogram(CheckM3, x = "Strain_heterogeneity", add = "mean", rug = TRUE,bins=100,color="darkred")
v5 = gghistogram(data.frame(CheckM3), x = "N50", add = "mean", rug = TRUE,bins=100,color="darkred")
v6 = gghistogram(data.frame(CheckM3), x = "scaffolds", add = "mean", rug = TRUE,bins=100,color="darkred")
g10 = gghistogram(CheckM4, x = "Completeness", add = "mean", rug = TRUE,bins=100,color="darkred")
g11 = gghistogram(CheckM4, x = "Contamination", add = "mean", rug = TRUE,bins=100,color="darkred")
g12 = gghistogram(CheckM4, x = "Strain_heterogeneity", add = "mean", rug = TRUE,bins=100,color="darkred")
v7 = gghistogram(data.frame(CheckM4), x = "N50", add = "mean", rug = TRUE,bins=100,color="darkred")
v8 = gghistogram(data.frame(CheckM4), x = "scaffolds", add = "mean", rug = TRUE,bins=100,color="darkred")
multiplot(g1,g4,g7,g10,g2,g5,g8,g11,g3,g6,g9,g12,v1,v3,v5,v7,v2,v4,v6,v8,cols=5)

#we quickly condens the number of genomes retained per stringency in a table, which can be plotted
STRCheckM = data.frame(cbind('stringency'=c('all_genomes','high_stringency','very_high_stringency','maximum_stringency'),'nr_of_genomes'=c(dim(CheckM)[1],dim(CheckM2)[1],dim(CheckM3)[1],dim(CheckM4)[1])))
STRCheckM$nr_of_genomes=as.numeric(as.character(STRCheckM$nr_of_genomes))
ggbarplot(STRCheckM, x = "stringency", y = "nr_of_genomes",fill='black',color = "black",sort.val = "desc",sort.by.groups = FALSE,x.text.angle = 45) + scale_y_continuous( expand = c(0, 0))

print(STRCheckM)

# STEP TWO: Compare the results of different CheckM filter stringencies to the values obtained from ANVIO
#--------------------------------------------------------------------------------------------------------------------------------------------------------------

#ANVIO UNFILTERED
g13 = gghistogram(CheckMANVIO, x = "percent_completion", add = "mean", rug = TRUE,bins=100,color="darkred")
g14 = gghistogram(CheckMANVIO, x = "percent_redundancy", add = "mean", rug = TRUE,bins=100,color="darkred")
g15 = gghistogram(CheckMANVIO2, x = "percent_completion", add = "mean", rug = TRUE,bins=100,color="darkred")
g16 = gghistogram(CheckMANVIO2, x = "percent_redundancy", add = "mean", rug = TRUE,bins=100,color="darkred")
multiplot(g13,g15,g14,g16,cols=2)

#ANVIO FILTERED
g13 = gghistogram(CheckMANVIO2, x = "Completeness", add = "mean", rug = TRUE,bins=100,color="darkred")
g14 = gghistogram(CheckMANVIO2, x = "Contamination", add = "mean", rug = TRUE,bins=100,color="darkred")
g15 = gghistogram(CheckMANVIO2, x = "percent_completion", add = "mean", rug = TRUE,bins=100,color="darkred")
g16 = gghistogram(CheckMANVIO2, x = "percent_redundancy", add = "mean", rug = TRUE,bins=100,color="darkred")
multiplot(g13,g15,g14,g16,cols=2)

#BUSCO UNFILTERED
g18 = gghistogram(BUSCOcheck, x = "S", add = "mean", rug = TRUE,bins=100,color="darkred")
g19 = gghistogram(BUSCOcheck, x = "D", add = "mean", rug = TRUE,bins=100,color="darkred")
g20 = gghistogram(BUSCOcheck, x = "F", add = "mean", rug = TRUE,bins=100,color="darkred")
g21 = gghistogram(BUSCOcheck, x = "M", add = "mean", rug = TRUE,bins=100,color="darkred")
multiplot(g18, g19, g20, g21,cols=4)

#BUSCO FILTERED
BUSCOCheckMANVIO = right_join(BUSCOcheck , CheckMANVIO2, by=c('Bin_Id'))
g22 = gghistogram(BUSCOCheckMANVIO, x = "S", add = "mean", rug = TRUE,bins=100,color="darkred")
g23 = gghistogram(BUSCOCheckMANVIO, x = "D", add = "mean", rug = TRUE,bins=100,color="darkred")
g24 = gghistogram(BUSCOCheckMANVIO, x = "F", add = "mean", rug = TRUE,bins=100,color="darkred")
g25 = gghistogram(BUSCOCheckMANVIO, x = "M", add = "mean", rug = TRUE,bins=100,color="darkred")
multiplot(g18,g22, g19, g23,g20, g24,g21,g25,cols=4)


################################################################

#--------------------------------------------------------------------------------------------
#	per clade?
#--------------------------------------------------------------------------------------------
ANVIO_cat2 = ANVIO_cat
names(ANVIO_cat2)=c('Bin_Id','group','group2','lifestyle','SS','sourceClass','lat','lon')
CheckM2_annotated = right_join(CheckMANVIO2, ANVIO_cat2, by=c('Bin_Id'))
CheckM2_annotated = right_join(ANVIO_cat2, CheckMANVIO2, by=c('Bin_Id'))


#--------------------------------------------------------------------------------------------
# 	Genome SIMILARITY?
# 	ANI, AAI, ANI, codon_usage, kmer_usage  
#--------------------------------------------------------------------------------------------

#	ANIb is calcultated through pyani.py
#	AAI is calculated with compareM

#------ AVERAGE NUCLEOTIDE IDENTITY------------

ANIb = as.matrix(read.table('~/ANIb/ANIb_percentage_identity.tab',header=TRUE))
ANIb = ANIb[CheckMANVIO2$Bin_Id,CheckMANVIO2$Bin_Id]
 heatmap.2(as.matrix(data.matrix(ANIb)),trace="none",scale="none",col=colorRampPalette(c("blue4", 'cyan4', "cadetblue1",'darkgoldenrod1','yellow'))(n = 150),dendrogram="row",RowSideColors= cladecolors)

AliCov = as.matrix(read.table('~/ANIb/ANIb_alignment_coverage.tab',header=TRUE))
AliCov = AliCov[CheckMANVIO2$Bin_Id,CheckMANVIO2$Bin_Id]
 heatmap.2(as.matrix(data.matrix(AliCov)),trace="none",scale="none",col=colorRampPalette(c("blue4", 'cyan4', "cadetblue1",'darkgoldenrod1','yellow'))(n = 150),dendrogram="row",RowSideColors= cladecolors)
heatmap.2(as.matrix(data.matrix(cor(t(AliCov),method = 'pearson'))),trace="none",scale="none",col=colorRampPalette(c("blue4","blue4","blue4","blue4","blue4","blue4","blue4","blue4","blue4","blue4",'cyan4','cyan4','cyan4','cyan4' ,"cadetblue1","cadetblue1","cadetblue1",'darkgoldenrod1','yellow'))(n = 150),dendrogram="row", RowSideColors= cladecolors)

AliLengths = as.matrix(read.table('~/ANIb/ANIb_alignment_lengths.tab',header=TRUE))
AliLengths = AliLengths[CheckMANVIO2$Bin_Id,CheckMANVIO2$Bin_Id]
 heatmap.2(as.matrix(data.matrix(AliLengths)),trace="none",scale="none",col=colorRampPalette(c("blue4", 'cyan4', "cadetblue1",'darkgoldenrod1','yellow'))(n = 150),dendrogram="row",RowSideColors= cladecolors)
heatmap.2(as.matrix(data.matrix(cor(t(AliLengths),method = 'pearson'))),trace="none",scale="none",col=colorRampPalette(c("blue4","blue4","blue4","blue4","blue4","blue4","blue4","blue4","blue4","blue4",'cyan4','cyan4','cyan4','cyan4' ,"cadetblue1","cadetblue1","cadetblue1",'darkgoldenrod1','yellow'))(n = 150),dendrogram="row", RowSideColors= cladecolors)

Tetra = as.matrix(read.table('~/TETRA/TETRA_correlations.tab',header=TRUE))
Tetra = Tetra[CheckMANVIO2$Bin_Id,CheckMANVIO2$Bin_Id]
 heatmap.2(as.matrix(data.matrix(Tetra)),trace="none",scale="none",col=colorRampPalette(c("blue4","blue4","blue4","blue4","blue4","blue4","blue4","blue4", 'cyan4', "cadetblue1",'darkgoldenrod1','yellow'))(n = 150),dendrogram="row",RowSideColors= cladecolors)
heatmap.2(as.matrix(data.matrix(cor(t(Tetra),method = 'pearson'))),trace="none",scale="none",col=colorRampPalette(c("blue4","blue4","blue4","blue4","blue4","blue4","blue4","blue4","blue4","blue4",'cyan4','cyan4','cyan4','cyan4' ,"cadetblue1","cadetblue1","cadetblue1",'darkgoldenrod1','yellow'))(n = 150),dendrogram="row", RowSideColors= cladecolors)

#Pearson correlations between Z-score distributions for each tetranucleotide in each input sequence (TETRA).


#------ COMPAREM------------
CompareM =read.table("~/Downloads/compareM/aai_summary.tsv",header=TRUE)
AA_table =read.table("~/DATA/MarinobacterGenomics/2018_ProkComp/AA_table.txt",header=TRUE)
AA_table = AA_table[order(AA_table$One_letter_code),]
AA_table = AA_table[! AA_table$One_letter_code %in% c("B","Z"),]

#------ AMINO ACID IDENTITY------------
dat = CompareM[,c("Genome_A","Genome_B","Mean_AAI")]
g <- graph.data.frame(dat, directed=FALSE)
AAI = get.adjacency(g, attr="Mean_AAI", sparse=FALSE)
AAI[AAI<1] <- 100

#make sure we remove the low_quality genomes
AAI = AAI[CheckMANVIO2$Bin_Id,CheckMANVIO2$Bin_Id]

 heatmap.2(as.matrix(data.matrix(AAI)),trace="none",scale="none",col=colorRampPalette(c("blue4", 'cyan4', "cadetblue1",'darkgoldenrod1','yellow'))(n = 150),dendrogram="row",RowSideColors= cladecolors)
 
#------ Ortholog Fraction ------------
dat = CompareM[,c("Genome_A","Genome_B","Orthologous_fraction")]
g <- graph.data.frame(dat, directed=FALSE)
Ortfrac = get.adjacency(g, attr="Orthologous_fraction", sparse=FALSE)
Ortfrac[Ortfrac <1] <- 100

#make sure we remove the low_quality genomes
Ortfrac = Ortfrac[CheckMANVIO2$Bin_Id,CheckMANVIO2$Bin_Id]

heatmap.2(Ortfrac,trace="none",scale="none",col=colorRampPalette(c("blue4", 'cyan4', "cadetblue1",'darkgoldenrod1','yellow'))(n = 150),dendrogram="row",RowSideColors= cladecolors)

#------ AA usage ------------
aa_usage=read.table("~/Downloads/compareM/aa_usage.txt",header=TRUE)
aa_usage2 = aa_usage[,2:length(colnames(aa_usage))]
rownames(aa_usage2) = aa_usage$Genome_ID
aa_usage2 = aa_usage2[CheckMANVIO2$Bin_Id,]

# remove the ambigious and uninterpretable "X" amino acid...
aa_usage2 = aa_usage2[,!colnames(aa_usage2) %in% c("X")]
colnames(aa_usage2) = AA_table$Amino_acid

#based on pearson correlation
heatmap.2(as.matrix(data.matrix(cor(t(aa_usage2),method = 'pearson'))),trace="none",scale="none",col=colorRampPalette(c("blue4", "blue4", "blue4","blue4","blue4","blue4", 'cyan4','cyan4','cyan4','cyan4' ,"cadetblue1","cadetblue1","cadetblue1",'darkgoldenrod1','yellow'))(n = 150),dendrogram="row", ,RowSideColors= cladecolors)

#have a look which one of them are deviating
heatmap.2(as.matrix(t(aa_usage2)),trace="none",scale="row",col=colorRampPalette(c('darkred','red','white','blue','darkblue'))(n = 150),dendrogram="column", ,ColSideColors= cladecolors,margins=c(10,10))

#------ Ortholog genes ------------
dat = CompareM[,c("Genome_A","Genome_B","orthologous_genes")]
g <- graph.data.frame(dat, directed=FALSE)
OrtGen = get.adjacency(g, attr="orthologous_genes", sparse=FALSE)

#make sure we remove the low_quality genomes
OrtGen = OrtGen[CheckMANVIO2$Bin_Id,CheckMANVIO2$Bin_Id]


#------ Codon usage ------------

codon_usage =read.table("~/Downloads/compareM/codon_usage.txt",header=TRUE)
codon_usage2 = codon_usage[,2:length(colnames(codon_usage))]
rownames(codon_usage2) = codon_usage$Genome_ID
codon_usage2 = codon_usage2[CheckMANVIO2$Bin_Id,]

heatmap.2(as.matrix(codon_usage2),trace="none",scale="none",col=colorRampPalette(c("blue4", 'cyan4', "cadetblue1",'darkgoldenrod1','yellow'))(n = 150),dendrogram="row")
codonLong = melt(codon_usage)
heatmap.2(as.matrix(data.matrix(cor(t(codon_usage2),method = 'pearson'))),trace="none",scale="none",col=colorRampPalette(c("blue4", "blue4", "blue4","blue4","blue4","blue4","blue4","blue4","blue4","blue4", "blue4","blue4","blue4","blue4","blue4","blue4",'cyan4','cyan4','cyan4','cyan4' ,"cadetblue1","cadetblue1","cadetblue1",'darkgoldenrod1','yellow'))(n = 150),dendrogram="row", ,RowSideColors= cladecolors)
heatmap.2(as.matrix(data.matrix(dist((codon_usage2),method = 'euclidian'))),trace="none",scale="none",col=colorRampPalette(c("blue4", 'cyan4', "cadetblue1",'darkgoldenrod1','yellow'))(n = 150),dendrogram="row", ,RowSideColors= colorRampPalette(c( "yellow", "forestgreen",'red'))(n = 12)[as.numeric(ANVIO_cat_restricted$group2)])


heatmap.2(as.matrix(t(codon_usage2[, colnames(codon_usage2)%in%c("C","G",'T','A')])),trace="none",scale="row",col=colorRampPalette(c('darkred','red','white','blue','darkblue'))(n = 150),dendrogram="column", ,ColSideColors= cladecolors,margins=c(20,20))




#  COMBINE MEASURES AND CORRELATE/VISUALISE
#------------------------------------------------------------
#euclidian distances
distAAusage = data.matrix(dist(aa_usage2,method = 'euclidian'))
distCODONusage = data.matrix(dist(codon_usage2,method = 'euclidian'))
distAliLengths = data.matrix(dist(AliLengths,method = 'euclidian'))

#pearson correlation
corAAusage = data.matrix(cor(t(aa_usage2),method = 'pearson'))
corAAusage = data.matrix(cor(t(codon_usage2),method = 'pearson'))
corAliLengths = data.matrix(cor(t(AliLengths),method = 'pearson'))


AALong = melt(distAAusage)
codonLong = melt(distCODONusage)
corAALong = melt(corAAusage)
corcodonLong = melt(corAAusage)
AAIlong = melt(AAI)
Ortfraclong = melt(Ortfrac)
ANIblong = melt(ANIb)
AliLengthslong = melt(distAliLengths)
AliCovlong = melt(AliCov)
TetraLong = melt(Tetra)

combinedAA_Codon = data.frame(cbind('distAA'=AALong$value,'distCodon'= codonLong$value,'corAA'=corAALong$value,'corCodon'=corcodonLong$value,'AAI'=AAIlong $value,'OrtFrac'=Ortfraclong $value,'ANIb'= ANIblong$value,'distAliLengths'= AliLengthslong$value,'AliCov'= AliCovlong$value, 'Tetra'=TetraLong$value))

u1 = ggscatter(combinedAA_Codon, x = "AAI", y = "OrtFrac", size = 0.5, alpha = 1,add = c("reg.line"),add.params = list(size=0.1,color = "darkgrey", fill = "lightgray"),conf.int = TRUE, cor.coef = TRUE, cor.coeff.args = list(method = "pearson", label.x = 75, label.sep = "\n"),rug = TRUE)
u2 = ggscatter(combinedAA_Codon, x = "AAI", y = "distAA", size = 0.5, alpha = 1,add = "loes",add.params = list(size=0.1,color = "darkgrey", fill = "lightgray"),conf.int = TRUE, cor.coef = TRUE, cor.coeff.args = list(method = "pearson", label.x = 75, label.sep = "\n"),rug = TRUE)
u3 = ggscatter(combinedAA_Codon, x = "AAI", y = "distCodon", size = 0.5, alpha = 1,add = "loes",add.params = list(size=0.1,color = "darkgrey", fill = "lightgray"),conf.int = TRUE, cor.coef = TRUE, cor.coeff.args = list(method = "pearson", label.x = 75, label.sep = "\n"),rug = TRUE)
u4 = ggscatter(combinedAA_Codon, x = "OrtFrac", y = "distAA", size = 0.5, alpha = 1,add = c("reg.line"),add.params = list(size=0.1,color = "darkgrey", fill = "lightgray"),conf.int = TRUE, cor.coef = TRUE, cor.coeff.args = list(method = "pearson", label.x = 50, label.sep = "\n"),rug = TRUE)
u5 = ggscatter(combinedAA_Codon, x = "OrtFrac", y = "distCodon", size = 0.5, alpha = 1,add = c("reg.line"),add.params = list(size=0.1,color = "darkgrey", fill = "lightgray"),conf.int = TRUE, cor.coef = TRUE, cor.coeff.args = list(method = "pearson", label.x = 50, label.sep = "\n"),rug = TRUE)
u6 = ggscatter(combinedAA_Codon, x = "distAA", y = "distCodon", size = 0.5, alpha = 1,add = c("reg.line"),add.params = list(size=0.1,color = "darkgrey", fill = "lightgray"),conf.int = TRUE, cor.coef = TRUE, cor.coeff.args = list(method = "pearson", label.x = 0.45, label.sep = "\n"),rug = TRUE)
u7 = ggscatter(combinedAA_Codon, x = "distAA", y = "corAA", size = 0.5, alpha = 1,add = "loes",add.params = list(size=0.1,color = "darkgrey", fill = "lightgray"),conf.int = TRUE, cor.coef = TRUE, cor.coeff.args = list(method = "pearson", label.x = 0.9, label.sep = "\n"),rug = TRUE)
u8 = ggscatter(combinedAA_Codon, x = "distCodon", y = "corCodon", size = 0.5, alpha = 1,add = "loes",add.params = list(size=0.1,color = "darkgrey", fill = "lightgray"),conf.int = TRUE, cor.coef = TRUE, cor.coeff.args = list(method = "pearson", label.x = 0.3, label.sep = "\n"),rug = TRUE)
u9 = ggscatter(combinedAA_Codon, x = "corAA", y = "corCodon", size = 0.5, alpha = 1,add = "reg.line",add.params = list(size=0.1,color = "darkgrey", fill = "lightgray"),conf.int = TRUE, cor.coef = TRUE, cor.coeff.args = list(method = "pearson", label.x = 0.98, label.sep = "\n"),rug = TRUE)
u10 = ggscatter(combinedAA_Codon, x = "ANIb", y = "AAI", size = 0.5, alpha = 1,add = "loes",add.params = list(size=0.1,color = "darkgrey", fill = "lightgray"),conf.int = TRUE, cor.coef = TRUE, cor.coeff.args = list(method = "pearson", label.sep = "\n"),rug = TRUE)
u11 = ggscatter(combinedAA_Codon, x = "ANIb", y = "OrtFrac", size = 0.5, alpha = 1,add = "loes",add.params = list(size=0.1,color = "darkgrey", fill = "lightgray"),conf.int = TRUE, cor.coef = TRUE, cor.coeff.args = list(method = "pearson", label.sep = "\n"),rug = TRUE)
u12 = ggscatter(combinedAA_Codon, x = "ANIb", y = "distAA", size = 0.5, alpha = 1,add = "loes",add.params = list(size=0.1,color = "darkgrey", fill = "lightgray"),conf.int = TRUE, cor.coef = TRUE, cor.coeff.args = list(method = "pearson", label.sep = "\n"),rug = TRUE)
u13 = ggscatter(combinedAA_Codon, x = "ANIb", y = "distAliLengths", size = 0.5, alpha = 1,add = "loes",add.params = list(size=0.1,color = "darkgrey", fill = "lightgray"),conf.int = TRUE, cor.coef = TRUE, cor.coeff.args = list(method = "pearson", label.sep = "\n"),rug = TRUE)
u14 = ggscatter(combinedAA_Codon, x = "ANIb", y = "AliCov", size = 0.5, alpha = 1,add = "loes",add.params = list(size=0.1,color = "darkgrey", fill = "lightgray"),conf.int = TRUE, cor.coef = TRUE, cor.coeff.args = list(method = "pearson", label.sep = "\n"),rug = TRUE)
u15 = ggscatter(combinedAA_Codon, x = "ANIb", y = "distCodon", size = 0.5, alpha = 1,add = "loes",add.params = list(size=0.1,color = "darkgrey", fill = "lightgray"),conf.int = TRUE, cor.coef = TRUE, cor.coeff.args = list(method = "pearson", label.sep = "\n"),rug = TRUE)

ggscatter(combinedAA_Codon, x = "AliCov", y = "distAliLengths", size = 0.5, alpha = 1,add = "loes",add.params = list(size=0.1,color = "darkgrey", fill = "lightgray"),conf.int = TRUE, cor.coef = TRUE, cor.coeff.args = list(method = "pearson", label.sep = "\n"),rug = TRUE)

ggscatter(combinedAA_Codon, x = "ANIb", y = "Tetra", size = 0.5, alpha = 1,add = "loes",add.params = list(size=0.1,color = "darkgrey", fill = "lightgray"),conf.int = TRUE, cor.coef = TRUE, cor.coeff.args = list(method = "pearson", label.sep = "\n"),rug = TRUE)

multiplot(u10,u11,u12,u13,u14,u15,cols=3)
multiplot(u1,u2,u3,u4,u5,u6,u7,u8,u9,cols=3)
multiplot(u10,u11,u12,u13,u14,u15,u1,u2,u3,u4,u5,u6,u7,u8,u9,cols=5)

hist1 = gghistogram(AALong,x='value',color='darkgreen', fill = "darkgreen", add = "mean",bins=57,title='AA_usage')
hist2 = gghistogram(codonLong,x='value',color='darkgreen', fill = "darkgreen", add = "mean",bins=57,title='Codon_usage')
hist3 = gghistogram(AAIlong,x='value',color='darkgreen', fill = "darkgreen", add = "mean",bins=57,title='AAI')
hist4 = gghistogram(Ortfraclong,x='value',color='darkgreen', fill = "darkgreen", add = "mean",bins=57,title='OrthFrac')
hist5 = gghistogram(ANIblong,x='value',color='darkgreen', fill = "darkgreen", add = "mean",bins=57,title='ANIb')
hist6 = gghistogram(AliCovlong,x='value',color='darkgreen', fill = "darkgreen", add = "mean",bins=57,title='Alignment coverage')
hist7 = gghistogram(AliLengthslong,x='value',color='darkgreen', fill = "darkgreen", add = "mean",bins=57,title='Alignment length')
hist8 = gghistogram(TetraLong,x='value',color='darkgreen', fill = "darkgreen", add = "mean",bins=57,title='Tetranucleotide frequency')

multiplot( hist3, hist4,hist5,hist8,hist6,hist7,hist1, hist2,cols=4)

AAI3 = AAI
colnames(AAI3)[1] = "name"
combinedAAI3 = right_join(ANVIO_cat, AAI3, by='name')


#--------------------------------------------------------------------------------------------
# 	similarity per clade? 
#--------------------------------------------------------------------------------------------

meltGroup = function(corMat, metaTax,group){
	metaTax = metaTax[rownames(corMat),]
	moltencorMat = melt(corMat)
	moltencorMat$groupX1 = metaTax[moltencorMat$X1, group]
	moltencorMat$groupX2 = metaTax[moltencorMat$X2, group]
	moltencorMat$taxorder = ifelse(moltencorMat$X1==moltencorMat$X2,"itself",ifelse(moltencorMat$groupX1 ==moltencorMat$groupX2,"within_group","among_group"))
	return(moltencorMat)
}

AAIgroup = meltGroup(AAI, ANVIO_cat,'group2')


ggplot(data= AAIgroup,aes(x= reorder(groupX1,value),y= value,colour=taxorder))+geom_jitter(size=0.2)+theme_classic()+theme(axis.text.x = element_text(angle = 90, hjust = 1, size=10),axis.text.y = element_text(size=10))+scale_colour_manual(values=c("black","darkgray",'lightgray'))+geom_hline(yintercept = 95,colour='gray')+geom_hline(yintercept = 96,colour='gray')

ggplot(data= AAIgroup[AAIgroup$taxorder != 'itself',],aes(x= reorder(groupX1,value),y= value,colour=taxorder))+geom_jitter(size=0.2)+theme_classic()+theme(axis.text.x = element_text(angle = 90, hjust = 1, size=10),axis.text.y = element_text(size=10))+scale_colour_manual(values=c("black","darkgray",'lightgray'))+geom_hline(yintercept = 95,colour='gray')+geom_hline(yintercept = 96,colour='gray')

ggplot(data= AAIgroup[AAIgroup$taxorder != 'itself',],aes(x= reorder(groupX1,value),y= value,fill=taxorder))+geom_boxplot()+theme_classic()+theme(axis.text.x = element_text(angle = 90, hjust = 1, size=10),axis.text.y = element_text(size=10))+scale_fill_manual(values=c("black","darkgray",'lightgray'))+geom_hline(yintercept = 95,colour='gray')+geom_hline(yintercept = 96,colour='gray')

ggplot(data= AAIgroup[AAIgroup$taxorder != 'itself',],aes(x= reorder(groupX1,value),y= value,fill=taxorder))+geom_bar(stat='identity',position='dodge')+theme_classic()+theme(axis.text.x = element_text(angle = 90, hjust = 1, size=10),axis.text.y = element_text(size=10))+scale_fill_manual(values=c("black","darkgray",'lightgray'))+geom_hline(yintercept = 95,colour='gray')+geom_hline(yintercept = 96,colour='gray')+scale_y_continuous(expand = c(0, 0))



AAIgroup = meltGroup(AAI, ANVIO_cat,'group2')
ds <- plyr::ddply(AAIgroup[AAIgroup$taxorder != 'itself',] , c("groupX1",'taxorder'),plyr::summarise, mean = mean(value), sd = sd(value))

g.aai1 = ggplot(ds, aes(x=reorder(groupX1,mean), y= mean, fill= taxorder)) + geom_bar(position=position_dodge(), stat="identity") + geom_errorbar(aes(ymin= mean-sd, ymax= mean +sd),width=.2,position=position_dodge(.9))+ylab('AAI') + xlab("group") + theme_classic() + theme(legend.position="bottom",axis.text.x = element_text(angle=90,hjust=1))+geom_hline(yintercept = 95,colour='gray')+geom_hline(yintercept = 96,colour='gray')+scale_y_continuous(expand = c(0, 0))+scale_fill_manual(values=c("black","darkgray",'lightgray'))+coord_cartesian(ylim = c(50, 100))

AAIgroup2 = meltGroup(AAI, ANVIO_cat,'SS')
ds <- plyr::ddply(AAIgroup2[AAIgroup2 $taxorder != 'itself',] , c("groupX1",'taxorder'),plyr::summarise, mean = mean(value), sd = sd(value))
g.aai2 = ggplot(ds, aes(x=reorder(groupX1,mean), y= mean, fill= taxorder)) + geom_bar(position=position_dodge(), stat="identity") + geom_errorbar(aes(ymin= mean-sd, ymax= mean +sd),width=.2,position=position_dodge(.9))+ylab('AAI') + xlab("group") + theme_classic() + theme(legend.position="bottom",axis.text.x = element_text(angle=90,hjust=1))+geom_hline(yintercept = 95,colour='gray')+geom_hline(yintercept = 96,colour='gray')+scale_y_continuous(expand = c(0, 0))+scale_fill_manual(values=c("black","darkgray",'lightgray'))+coord_cartesian(ylim = c(50, 100))

ANIgroup = meltGroup(ANIb*100, ANVIO_cat,'group2')
ds <- plyr::ddply(ANIgroup[ANIgroup $taxorder != 'itself',] , c("groupX1",'taxorder'),plyr::summarise, mean = mean(value), sd = sd(value))

g.ani1 = ggplot(ds, aes(x=reorder(groupX1,mean), y= mean, fill= taxorder)) + geom_bar(position=position_dodge(), stat="identity") + geom_errorbar(aes(ymin= mean-sd, ymax= mean +sd),width=.2,position=position_dodge(.9))+ylab('ANIb') + xlab("group") + theme_classic() + theme(legend.position="bottom",axis.text.x = element_text(angle=90,hjust=1))+geom_hline(yintercept = 95,colour='gray')+geom_hline(yintercept = 96,colour='gray')+scale_y_continuous(expand = c(0, 0))+scale_fill_manual(values=c("black","darkgray",'lightgray')) +coord_cartesian(ylim = c(50, 100))



ANIgroup2 = meltGroup(ANIb*100, ANVIO_cat,'SS')
ds <- plyr::ddply(ANIgroup2[ANIgroup2 $taxorder != 'itself',] , c("groupX1",'taxorder'),plyr::summarise, mean = mean(value), sd = sd(value))
g.ani2 = ggplot(ds, aes(x=reorder(groupX1,mean), y= mean, fill= taxorder)) + geom_bar(position=position_dodge(), stat="identity") + geom_errorbar(aes(ymin= mean-sd, ymax= mean +sd),width=.2,position=position_dodge(.9))+ylab('ANIb') + xlab("group") + theme_classic() + theme(legend.position="bottom",axis.text.x = element_text(angle=90,hjust=1))+geom_hline(yintercept = 95,colour='gray')+geom_hline(yintercept = 96,colour='gray')+scale_y_continuous(expand = c(0, 0))+scale_fill_manual(values=c("black","darkgray",'lightgray'))+coord_cartesian(ylim = c(50, 100))


multiplot(g.aai1, g.aai2, g.ani1, g.ani2,cols=2)


#--------------------------------------------------------------------------------------------
# 	GENOME STATISTICS 
#--------------------------------------------------------------------------------------------

alreadycompared = c()
AllCombinations = list()
listPosition = 1

for(i in unique(CheckM2_annotated$group2)){
	alreadycompared = c(alreadycompared,i)
	for(o in unique(unique(CheckM2_annotated[!(CheckM2_annotated$group2 %in% alreadycompared),'group2']))){
	AllCombinations[[listPosition]]= c(i,o)	
	listPosition = listPosition + 1
	}
}

# ------- Genome_size -------
PostHoc = TukeyHSD(aov(Genome_size ~ group2,  data = CheckM2_annotated))$group2
combinations = strsplit(rownames(PostHoc[PostHoc[,4]<0.1,]),'-')
p1 <- ggboxplot(CheckM2_annotated, x = "group2", y = "Genome_size",
                color = "group2", palette ="jco",
                add = "jitter", fill = "white") +theme(axis.text.x=element_text(angle=45,hjust=1))+rremove("legend") + stat_compare_means(comparisons = combinations,label = "p.signif")+ stat_compare_means(label.y = max(CheckM2_annotated$Genome_size))

# ------- Genome_size -------
a <- aov(Genome_size~ group2, data= CheckM2_annotated)
tHSD <- TukeyHSD(a, ordered = FALSE, conf.level = 0.95)
p1 <- ggboxplot(CheckM2_annotated, x = "group2", y = "Genome_size",
                color = "group2", palette ="jco",
                add = "jitter", fill = "white",add.params = list(size = 0.75)) +theme(axis.text.x=element_text(angle=45,hjust=1))+rremove("legend") + geom_text(data = generate_label_df(tHSD, 'group2'), aes(x = plot.labels, y = max((CheckM2_annotated $Genome_size)), label = labels))+ stat_compare_means(label.y = max(CheckM2_annotated$Genome_size)-100000)

# ------- GC -------
a <- aov(GC ~ group2, data= CheckM2_annotated)
tHSD <- TukeyHSD(a, ordered = FALSE, conf.level = 0.95)
p2 <- ggboxplot(CheckM2_annotated, x = "group2", y = "GC",
                color = "group2", palette ="jco",
                add = "jitter", fill = "white",add.params = list(size = 0.75)) +theme(axis.text.x=element_text(angle=45,hjust=1))+rremove("legend") + stat_compare_means(label.y = max(CheckM2_annotated$GC)-0.5) +geom_text(data = generate_label_df(tHSD, 'group2'), aes(x = plot.labels, y = max((CheckM2_annotated $GC)), label = labels))

# ------- Coding_density -------
a <- aov(Coding_density ~ group2, data= CheckM2_annotated)
tHSD <- TukeyHSD(a, ordered = FALSE, conf.level = 0.95)
p3 <- ggboxplot(CheckM2_annotated, x = "group2", y = "Coding_density",
                color = "group2", palette ="jco",
                add = "jitter", fill = "white",add.params = list(size = 0.75)) +theme(axis.text.x=element_text(angle=45,hjust=1))+rremove("legend")+ stat_compare_means(label.y = max(CheckM2_annotated$Coding_density)-0.1)+ geom_text(data = generate_label_df(tHSD, 'group2'), aes(x = plot.labels, y = max((CheckM2_annotated $Coding_density)), label = labels))

# ------- predicted_genes -------
a <- aov(predicted_genes ~ group2, data= CheckM2_annotated)
tHSD <- TukeyHSD(a, ordered = FALSE, conf.level = 0.95)
p4 <- ggboxplot(CheckM2_annotated, x = "group2", y = "predicted_genes",
                color = "group2", palette ="jco",
                add = "jitter", fill = "white",add.params = list(size = 0.75)) +theme(axis.text.x=element_text(angle=45,hjust=1))+rremove("legend") + stat_compare_means(label.y = max(CheckM2_annotated$predicted_genes) -200)+ geom_text(data = generate_label_df(tHSD, 'group2'), aes(x = plot.labels, y = max((CheckM2_annotated $predicted_genes)), label = labels))

multiplot(p1,p4,p2,p3,cols=4)

tapply(CheckM2_annotated $Genome_size, CheckM2_annotated $group2, summary)

bp1 = ggboxplot(CheckM2_annotated, x = "group2", y = "Genome_size", fill = "white",add.params = list(size = 0.75)) + ylab('Genome size')+theme(axis.text.x=element_text(angle=45,hjust=1))                
bp2 = ggboxplot(CheckM2_annotated, x = "group2", y = "predicted_genes", fill = "white",add.params = list(size = 0.75)) +ylab('Predicted genes')+theme(axis.text.x=element_text(angle=45,hjust=1))                
bp3 = ggboxplot(CheckM2_annotated, x = "group2", y = "GC", fill = "white",add.params = list(size = 0.75)) + ylab('%GC')+theme(axis.text.x=element_text(angle=45,hjust=1))                
bp4 = ggboxplot(CheckM2_annotated, x = "group2", y = "Coding_density", fill = "white",add.params = list(size = 0.75)) + ylab('Coding Density')+theme(axis.text.x=element_text(angle=45,hjust=1))                

multiplot(bp1,bp2,bp3,bp4,cols=2)            
                
                

#--------------------------------------------------------------------------------------------
#	Where the filtering truely happens
#--------------------------------------------------------------------------------------------

ANVIOrest=t(AnvioData)
ANVIOrest  = ANVIOrest[rownames(ANVIOrest) %in% CheckMANVIO2$Bin_Id,]


AnvioData =t(ANVIOrest)

AnvioData = AnvioData[,CheckMANVIO2$Bin_Id]
AnvioData  = AnvioData[!rowSums(AnvioData)==0,]
PA_AnvioData = AnvioData
PA_AnvioData[PA_AnvioData>1] <- 1 

#---- PFAM data --------------
PFAMrest=(PfamData)
PFAMrest  = PFAMrest[rownames(PFAMrest) %in% CheckMANVIO2$Bin_Id,]
PfamData =t(PFAMrest)
PfamData  = PfamData[!rowSums(PfamData)==0,]
PAPfamData = PfamData
PAPfamData[PAPfamData>1] <- 1 

#---- DUF data --------------
#generate a dataframe that contains only the DUF domains 
DUFData = PfamData[,grep("DUF", colnames(PfamData))]
PA_DUFData = DUFData
PA_DUFData[PA_DUFData>1] <- 1 

#---- META DATA --------------
#ANVIO_cat = read.table('~/outputtest.txt',header=TRUE,sep="\t")
#ANVIO_cat = read.table('~/DATA/MarinobacterGenomics/2018_ProkComp/ANVIO_CAT.txt',header=TRUE,sep="\t")

#---- DEDUPLICATION --------------
DEDUPLICATED =  subset(ANVIO, !duplicated(protein_cluster_id))


#--------------------------------------------------------------------------------------------
#	Load Phylogenetic tree and convert to dendrograms
#--------------------------------------------------------------------------------------------
# Currently, phylogenetic trees are generated outside prokcomp and have to be loaded manually
# In this example we load in RAxML generated newick files, from different matrices
# we include markersets identified by ANVIO, as SCO: single-cop orthologs, Campbell et al, Rinke et al, and ribosomal proteins
# trees are further mod point rooted and ladderized for aesthetic purposes

#load
#RAxMLANVIO = read.tree("~/DATA/MarinobacterGenomics/2018_ProkComp/SCO_682_RAxML_bipartitions_autosubst_b100")
#RAxMLCampbell = read.tree("~/DATA/MarinobacterGenomics/2018_ProkComp/RAxML_bipartitions.Campbell_AA")
#RAxMLRinke = read.tree("~/DATA/MarinobacterGenomics/2018_ProkComp/RAxML_bipartitions.Rinke_AA")
#RAxMLRiboProt = read.tree("~/DATA/MarinobacterGenomics/2018_ProkComp/RAxML_bipartitions.Ribosomal_AA")

RAxMLANVIO = read.tree("~/DATA/MarinobacterGenomics/2018_ProkComp/trees/SCO_kde.fas.treefile")
RAxMLRiboProt = read.tree("~/DATA/MarinobacterGenomics/2018_ProkComp/trees/concatenated_Ribosomal_proteins_AA.fa.bmge.treefile")
RAxMLCampbell = read.tree("~/DATA/MarinobacterGenomics/2018_ProkComp/trees/concatenated_Campbell_AA.fa.bmge.treefile")
RAxMLRinke = read.tree("~/DATA/MarinobacterGenomics/2018_ProkComp/trees/concatenated_Rinke_AA.fa.bmge.treefile")


#Root
RAxMLANVIORooted =  midpoint.root(RAxMLANVIO)
RAxMLCampbellRooted =  midpoint.root(RAxMLCampbell)
RAxMLRinkeRooted =  midpoint.root(RAxMLRinke)
RAxMLRiboProtRooted =  midpoint.root(RAxMLRiboProt)

#increasing branch lengths
tree2 <- ladderize(RAxMLANVIORooted, right = FALSE)
tree3 <- ladderize(RAxMLCampbellRooted, right = FALSE)
tree4 <- ladderize(RAxMLRinkeRooted, right = FALSE)
tree5 <- ladderize(RAxMLRiboProtRooted, right = FALSE)

#can’t have any branch lengths of zero or downstream commands will collapse those nodes…
tree2$edge.length[which(tree2$edge.length == 0)] <- 0.00001
rep_tree_um <- chronopl(tree2,lambda = 0.1,tol = 0)
rep_tree_d <- as.dendrogram(as.hclust.phylo(rep_tree_um))

tree3 $edge.length[which(tree3 $edge.length == 0)] <- 0.00001
rep_tree3_um <- chronopl(tree3,lambda = 0.1,tol = 0)
rep_tree3_d <- as.dendrogram(as.hclust.phylo(rep_tree3_um))

tree4$edge.length[which(tree4$edge.length == 0)] <- 0.00001
rep_tree4_um <- chronopl(tree4,lambda = 0.1,tol = 0)
rep_tree4_d <- as.dendrogram(as.hclust.phylo(rep_tree4_um))

tree5$edge.length[which(tree5$edge.length == 0)] <- 0.00001
rep_tree5_um <- chronopl(tree5,lambda = 0.1,tol = 0)
rep_tree5_d <- as.dendrogram(as.hclust.phylo(rep_tree5_um))


tr1 = ggtree(RAxMLANVIORooted) %<+% ANVIO_cat + geom_point(aes(color = group2)) + scale_colour_manual(values=colors)+ geom_text2(aes(label=label, subset=!isTip), hjust=1.2,vjust=-.5,size=2)+ggtitle('SCO')+geom_treescale()
tr2 = ggtree(RAxMLCampbellRooted)%<+% ANVIO_cat + geom_point(aes(color = group2)) + scale_colour_manual(values=colors)+ geom_text2(aes(label=label, subset=!isTip), hjust=1.2,vjust=-.5,size=2)+ggtitle('Campbell')+geom_treescale()
tr3 = ggtree(RAxMLRinkeRooted)%<+% ANVIO_cat + geom_point(aes(color = group2)) + scale_colour_manual(values=colors)+ geom_text2(aes(label=label, subset=!isTip), hjust=1.2,vjust=-.5,size=2)+ggtitle('Rinke')+geom_treescale()
tr4 = ggtree(RAxMLRiboProtRooted)%<+% ANVIO_cat + geom_point(aes(color = group2)) + scale_colour_manual(values=colors)+ geom_text2(aes(label=label, subset=!isTip), hjust=1.2,vjust=-.5,size=2)+ggtitle('Ribosomal Proteins')+geom_treescale()
multiplot(tr1,tr2,tr3,tr4,cols=4)


tanglegram(rep_tree4_d, rep_tree5_d)


PhyloDistMatrix<-cophenetic(tree2)
PhyloDistMatrix  = PhyloDistMatrix[ order(row.names(PhyloDistMatrix)), ]
PhyloDistMatrix  = PhyloDistMatrix[ , order(colnames(PhyloDistMatrix))]
melt3 <- melt(as.matrix(PhyloDistMatrix))[melt(upper.tri(as.matrix(PhyloDistMatrix)))$value,]

PhyloDistMatrix2<-cophenetic(tree4)
PhyloDistMatrix2  = PhyloDistMatrix2[ order(row.names(PhyloDistMatrix2)), ]
PhyloDistMatrix2  = PhyloDistMatrix2[ , order(colnames(PhyloDistMatrix2))]
melt4 <- melt(as.matrix(PhyloDistMatrix2))[melt(upper.tri(as.matrix(PhyloDistMatrix2)))$value,]

comparePhylo = data.frame('RAxMLANVIORooted' = melt3$value, 'RAxMLRinkeRooted' = melt4$value)
ggscatter(comparePhylo, x = "RAxMLANVIORooted", y = "RAxMLRinkeRooted", add = "loess", conf.int = TRUE)


#--------------------------------------------------------------------------------------------
#	ANNOTATED TREE
#---------------------------------------------------------------------------------------------
library(ggstance)

CheckM3_annotated = CheckM2_annotated
rownames(CheckM3_annotated) = CheckM3_annotated$Bin_Id
CheckM3_annotated  = CheckM3_annotated[tree2$tip.label,]
p <- ggtree(tree2,branch.length='none') %<+% CheckM3_annotated + geom_tippoint(aes(color=group2))

facet_plot(p, panel="SNP", geom=geom_point, mapping=aes(x= gc_content),data= CheckM3_annotated, pch='|', color="firebrick")  + theme_tree2()# %>%
    #facet_plot("BAR", CheckM2_annotated, geom_segment, aes(x=0, xend=dummy_bar_value, y=y, yend=y)) + theme_tree2()


p <- ggtree(tree2)


p <- ggtree(tree2,branch.length='none')
p1 <- p %<+% CheckM3_annotated[,c(1:10)] + geom_tippoint(aes(color=group2))+scale_colour_manual(values=colors)

p2 <- facet_plot(p1, panel="Genome_size", data= CheckM3_annotated, geom= geom_point, 
                aes(x= Genome_size), color='firebrick',stat='identity') + theme_tree2()                
d = data.frame(y=1:57,panel='Genome_size')
p2 = p2 + geom_hline(data=d,aes(yintercept=y))

p3  = facet_plot(p2, panel="predicted_genes", data= CheckM3_annotated, geom= geom_point, 
                aes(x= predicted_genes), color='firebrick',stat='identity') + theme_tree2()  
d = data.frame(y=1:57,panel='predicted_genes')
p3 = p3 + geom_hline(data=d,aes(yintercept=y))

p4  = facet_plot(p3, panel="GCcontent", data= CheckM3_annotated, geom= geom_point, 
                aes(x= GC), color='firebrick',stat='identity') + theme_tree2()  
d = data.frame(y=1:57,panel='GCcontent')
p4 = p4 + geom_hline(data=d,aes(yintercept=y))

p5  = facet_plot(p4, panel="Coding_density", data= CheckM3_annotated, geom= geom_point, 
                aes(x= Coding_density), color='firebrick',stat='identity') + theme_tree2()  
d = data.frame(y=1:57,panel='Coding_density')
p5 = p5 + geom_hline(data=d,aes(yintercept=y))

p6  = facet_plot(p5, panel="Contamination", data= CheckM3_annotated, geom= geom_point, 
                aes(x= Contamination), color='firebrick',stat='identity') + theme_tree2()  
d = data.frame(y=1:57,panel='Contamination')
p6 = p6 + geom_hline(data=d,aes(yintercept=y))

p7  = facet_plot(p6, panel="Completeness", data= CheckM3_annotated, geom= geom_point, 
                aes(x= Completeness), color='firebrick',stat='identity') + theme_tree2()  
d = data.frame(y=1:57,panel='Completeness')
p7 = p7 + geom_hline(data=d,aes(yintercept=y))

p7 + theme(axis.text.x = element_text(angle = 90, hjust = 1))

#--------------------------------------------------------------------------------------------
#	PHYLOGENETIC SIGNAL FOR CONTINIOUS TRAITS
#---------------------------------------------------------------------------------------------
# # Use the phylosignal function of the picante package to test for phylogenetic signal, measured with the K statistic.
# K ~ 1.0 suggests Brownian motion, K < 1 indicates less resemblance among relatives than expected under Brownian motion,
# and K > 1 indicates more resemblance among relatives than expected under Brownian motion (Blomberg et al., 2003, Evolution, 57:717-745).

library(pGLS)
library(geiger)
library(caper)
library(picante)
library(surface)
library(igraph)
library(phytools)
library(bayou)
library(OUwie)

tree=tree2
traits=CheckM3_annotated[,'GC']
names(traits)=CheckM3_annotated[,'Bin_Id']

#--------------Pagel's Lambda
#Basically, "λ is the transformation of the phylogeny that ensures the best fit of trait data to a Brownian Motion model".
#When λ equals 1, the structure of the phylogeny alone can explain changes in traits (explain covariance matrix of traits). In this scenario, traits follow a pure brownian motion model of evolution. On the other hand, when λ equals 0, the phylogeny has to become a 'star phylogeny' (i.e. to lose all its structure) to be able to explain trait evolution under a brownian motion model. Therefore, the phylogeny alone is not able to explain trait evolution. Also, λ can be greater than 1, what would suggest that the rate of evolution of a trait is higher at the root than it is at the tips.

#--------------Blomberg's K
#Blomberg's K is a relatively recent measure of phylogenetic signal. It is defined as the ratio between two other ratios. The first (observed) is the Mean Squared Error of tip data divided by the Mean Squared Error of data calculated using variance-covariance matrix derived from the phylogeny. The second ratio (expected) is the same thing, but using data from a model under the assumption of brownian motion of trait evolution. Thus, K<1 indicates that closely related species resemble each other less than expected under the Brownian motion model of trait evolution. K>1 means that closely related species are more similar than predicted by the model. In other words, greater values of K suggest strongest effects of phylogenetic signal.

PhSigResCont = c()
for(param in c('Genome_size','predicted_genes', 'GC', 'Coding_density', 'Contamination', 'Completeness'))
{
	traits=CheckM3_annotated[,param]
	names(traits)=CheckM3_annotated[,'Bin_Id']
	
	PhSigResCont = rbind(PhSigResCont , c(param,phylosig(tree, traits, method="lambda", test=TRUE, nsim=999),phylosig(tree,  traits, method="K", test=TRUE, nsim=999)))	
}


#--------------------------------------------------------------------------------------------
#	FUNCTIONAL DATA
#---------------------------------------------------------------------------------------------
library(phyloseq)

#count number of genomes in the dataset
number_of_genomes = length(colnames(AnvioData))

# number of genomes per PC and Pfam
sums = data.frame(rowSums(PA_AnvioData))
sumsPfam = data.frame(rowSums(PAPfamData))
colnames(sums) = c('value')
colnames(sumsPfam) = c('value')

#Combine in one dataframe
groupedDistribution = cbind(rbind(sumsPfam,sums),type = c(rep("domain",nrow(sumsPfam)),rep("PC",nrow(sums))))
#groupedDistribution = groupedDistribution[-c(which(groupedDistribution$value == 0)), ]

h1 =  gghistogram(sums, x = "value",color='darkred', fill = "darkred", add = "mean",bins=57,title='PC')
h2 =  gghistogram(sumsPfam, x = "value", color = 'darkblue',fill = "darkblue", add = "mean",bins=57,title='domain')
multiplot(h1,h2,cols=2)

sums$PC = rownames(sums)
selected_COGS = data.frame()
selected_COGS_all = data.frame('Var1'= unique(DEDUPLICATED$COG_CATEGORY_ACC))
for(i in c(5,10,15,20,25,30,35,40,45,50)){
	
	selectedSums = sums[sums$value>=i-5 & sums$value>=i ,'PC']
    selected_COGS = data.frame(sort(table(DEDUPLICATED[DEDUPLICATED $protein_cluster_id %in% selectedSums, 'COG_CATEGORY_ACC'])))
    selected_COGS_all = right_join(selected_COGS_all, selected_COGS, by='Var1')
	
}
rownames(selected_COGS_all) = selected_COGS_all$Var1
selected_COGS_all = selected_COGS_all[,2:11]
selected_COGS_all  = selected_COGS_all[!rowSums(selected_COGS_all)<10, ]

sumsAcc = data.frame(rowSums(AccesoryDF))
colnames(sumsAcc) = c('value')
gghistogram(sumsAcc, x = "value",color='darkred', fill = "darkred", add = "mean",bins=57,title='PC')


#----------------------------------------------
#	ORDINATION OF FUNCTIONAL SPACE
#----------------------------------------------
RareAccesoryDF  = AccesoryDF[!rowSums(AccesoryDF)<2,]
RareAccesoryDF  = RareAccesoryDF[!rowSums(RareAccesoryDF)>57-10,]
RareAccesoryDF = AnvioData[rownames(RareAccesoryDF),]
fullcount = as.matrix((RareAccesoryDF))
phseqAbundance = otu_table(as.data.frame.matrix(fullcount),taxa_are_rows=TRUE)

sampledata = sample_data(ANVIO_cat3)
sample_names(sampledata) = sample_names(phseqAbundance)
phyloseq = phyloseq(phseqAbundance, sampledata)

iMDS  <- ordinate(phyloseq, "MDS", distance='bray')
p1 <- plot_ordination(phyloseq, iMDS, color="group2")
p1 <- p1 + geom_point(size=1) + scale_colour_manual(values = colors)+ theme(legend.position="none",axis.line = element_line(colour="black"),axis.ticks = element_line(), panel.grid.major = element_blank(), panel.grid.minor = element_blank(),panel.background = element_blank())  + ggtitle(paste("2 - 57 :: Bray-Curtis", sep=""))
p2 <- plot_ordination(phyloseq, iMDS, color="SS")
p2 <- p2 + geom_point(size=1) + scale_colour_manual(values = Habitat_colors)+ theme(legend.position="none",axis.line = element_line(colour="black"),axis.ticks = element_line(), panel.grid.major = element_blank(), panel.grid.minor = element_blank(),panel.background = element_blank())  + ggtitle(paste("2 - 57 :: Bray-Curtis", sep=""))

iMDS  <- ordinate(phyloseq, "MDS", distance='jaccard')
p3 <- plot_ordination(phyloseq, iMDS, color="group2")
p3 <- p3 + geom_point(size=1) + scale_colour_manual(values = colors)+ theme(legend.position="none",axis.line = element_line(colour="black"),axis.ticks = element_line(), panel.grid.major = element_blank(), panel.grid.minor = element_blank(),panel.background = element_blank())  + ggtitle(paste("2 - 57 :: Jaccard", sep=""))
p4 <- plot_ordination(phyloseq, iMDS, color="SS")
p4 <- p4 + geom_point(size=1) + scale_colour_manual(values = Habitat_colors)+ theme(legend.position="none",axis.line = element_line(colour="black"),axis.ticks = element_line(), panel.grid.major = element_blank(), panel.grid.minor = element_blank(),panel.background = element_blank())  + ggtitle(paste("2 - 57 :: Jaccard", sep=""))

iMDS  <- ordinate(phyloseq, "MDS", distance='manhattan')
p5 <- plot_ordination(phyloseq, iMDS, color="group2")
p5 <- p5 + geom_point(size=1) + scale_colour_manual(values = colors)+ theme(legend.position="none",axis.line = element_line(colour="black"),axis.ticks = element_line(), panel.grid.major = element_blank(), panel.grid.minor = element_blank(),panel.background = element_blank())  + ggtitle(paste("2 - 57 :: Manhattan", sep=""))
p6 <- plot_ordination(phyloseq, iMDS, color="SS")
p6 <- p6 + geom_point(size=1) + scale_colour_manual(values = Habitat_colors)+ theme(legend.position="none",axis.line = element_line(colour="black"),axis.ticks = element_line(), panel.grid.major = element_blank(), panel.grid.minor = element_blank(),panel.background = element_blank())  + ggtitle(paste("2 - 57 :: Manhattan", sep=""))

multiplot(p1,p3,p5,p2,p4,p6,cols=2)

#----------------------------------------------
#	ORDINATION OF FUNCTIONAL SPACE
#----------------------------------------------

RarePfamDF  = PfamData[!rowSums(PfamData)<2,]
RarePfamDF  = RarePfamDF[!rowSums(RarePfamDF)>57-1,]
fullcount = as.matrix((RarePfamDF))
phseqAbundance = otu_table(as.data.frame.matrix(fullcount),taxa_are_rows=TRUE)

sampledata = sample_data(ANVIO_cat3)
sample_names(sampledata) = sample_names(phseqAbundance)
phyloseq = phyloseq(phseqAbundance, sampledata)

iMDS  <- ordinate(phyloseq, "MDS", distance='bray')
p1 <- plot_ordination(phyloseq, iMDS, color="group2")
p1 <- p1 + geom_point(size=1) + scale_colour_manual(values = colors)+ theme(legend.position="none",axis.line = element_line(colour="black"),axis.ticks = element_line(), panel.grid.major = element_blank(), panel.grid.minor = element_blank(),panel.background = element_blank())  + ggtitle(paste("2 - 57 :: Bray-Curtis", sep=""))
p2 <- plot_ordination(phyloseq, iMDS, color="SS")
p2 <- p2 + geom_point(size=1) + scale_colour_manual(values = Habitat_colors)+ theme(legend.position="none",axis.line = element_line(colour="black"),axis.ticks = element_line(), panel.grid.major = element_blank(), panel.grid.minor = element_blank(),panel.background = element_blank())  + ggtitle(paste("2 - 57 :: Bray-Curtis", sep=""))

iMDS  <- ordinate(phyloseq, "MDS", distance='jaccard')
p3 <- plot_ordination(phyloseq, iMDS, color="group2")
p3 <- p3 + geom_point(size=1) + scale_colour_manual(values = colors)+ theme(legend.position="none",axis.line = element_line(colour="black"),axis.ticks = element_line(), panel.grid.major = element_blank(), panel.grid.minor = element_blank(),panel.background = element_blank())  + ggtitle(paste("2 - 57 :: Jaccard", sep=""))
p4 <- plot_ordination(phyloseq, iMDS, color="SS")
p4 <- p4 + geom_point(size=1) + scale_colour_manual(values = Habitat_colors)+ theme(legend.position="none",axis.line = element_line(colour="black"),axis.ticks = element_line(), panel.grid.major = element_blank(), panel.grid.minor = element_blank(),panel.background = element_blank())  + ggtitle(paste("2 - 57 :: Jaccard", sep=""))

iMDS  <- ordinate(phyloseq, "MDS", distance='manhattan')
p5 <- plot_ordination(phyloseq, iMDS, color="group2")
p5 <- p5 + geom_point(size=1) + scale_colour_manual(values = colors)+ theme(legend.position="none",axis.line = element_line(colour="black"),axis.ticks = element_line(), panel.grid.major = element_blank(), panel.grid.minor = element_blank(),panel.background = element_blank())  + ggtitle(paste("2 - 57 :: Manhattan", sep=""))
p6 <- plot_ordination(phyloseq, iMDS, color="SS")
p6 <- p6 + geom_point(size=1) + scale_colour_manual(values = Habitat_colors)+ theme(legend.position="none",axis.line = element_line(colour="black"),axis.ticks = element_line(), panel.grid.major = element_blank(), panel.grid.minor = element_blank(),panel.background = element_blank())  + ggtitle(paste("2 - 57 :: Manhattan", sep=""))

multiplot(p1,p3,p5,p2,p4,p6,cols=2)





#----------------------------------------------
#----------------------------------------------
#----------------------------------------------
#	Bolch-idea
#----------------------------------------------
#----------------------------------------------
#----------------------------------------------
# "Bolch-idea", e.g. how robust the phylogeny-function link is with decreasing the dataset used.

#I did not get very far but have looped the calculation of some metrics (see attached files)
#the dataset has 57 genomes, so the accessory genes are those present in 2-56 genomes
#in essence, I decreased the upper boundary sequentially, (so, genes present in 2-56, 2-55, 2-54, ... , to only shared by 2 genomes)
#and basically calculated the following (for each of the subsets):
#1) jaccard distances among genomes, and correlated that to the jaccard distance among genomes using the full accessory set
#2) jaccard distances among genomes, and correlated that to phylogenetic distances
#3) calculated Baker's Gamma (a metric, to estimate cluster similarities) for clusterings obtained by the reduced vs full datasets
#4) calculated Baker's Gamma for clusterings obtained by the reduced datasets vs phylogenetic clustering

#additionally, I ran MDS ordination on each of the reduced datasets (selection is shown) on the basis of 3 widely used (abundance based) distance metrics, Bray, Jaccard and Manhattan 

data.frame(rowSums(PA_AnvioData))[,1]
rowSums(PA_AnvioData)
gghistogram(data.frame(rowSums(PA_AnvioData)), x = "rowSums.PA_AnvioData.", bins=57,color="darkred")
gghistogram(data.frame(rowSums(AccesoryDF)), x = "rowSums.AccesoryDF.", bins=55,color="darkred")
#gghistogram(data.frame(rowSums(RareAccesoryDF)), x = "rowSums.RareAccesoryDF.", bins=55,color="darkred")


library(corrplot)
totalPCs = dim(PA_AnvioData)[1]

#remove all the genes unique to a single genome
AccesoryDF = PA_AnvioData[!rowSums(PA_AnvioData)==1, ]

#remove all core genes
AccesoryDF  = AccesoryDF[! rowSums(AccesoryDF)== length(colnames(AccesoryDF)), ]


ANVIO_cat3 = ANVIO_cat2
rownames(ANVIO_cat3)= ANVIO_cat3$Bin_Id
ANVIO_cat3 = ANVIO_cat3[colnames(AccesoryDF),]


PhyloDistMatrix[ order(row.names(AccesoryDF)), ]

tree2_pruned = prune(rep_tree_d , rownames(PhyloDistMatrix[!(colnames(PhyloDistMatrix) %in% colnames(AccesoryDF)),]))


hist(rowSums(AccesoryDF))


JacD_tot = distJaccard(t(AccesoryDF))

ngenes = c()
lowerLimit =c()
JacCor = c()
bakersGam = c()
phylobakersGam = c()
phyloJacCor = c()

PhyloDistMatrix

dends=dendlist(as.dendrogram(hclust(JacD_tot)))
braylist = list()
jaccardlist =list()
manhattanlist =list()

jacDist_tracker = c()

for(i in 1:55){
	RareAccesoryDF  = AccesoryDF[!rowSums(AccesoryDF)<2,]
	RareAccesoryDF  = AccesoryDF[!rowSums(AccesoryDF)>57-(i),]
	print(dim(RareAccesoryDF))	
	ngenes = c(ngenes,dim(RareAccesoryDF)[1])
	lowerLimit = c(lowerLimit,57-(i))
	#hist(rowSums(RareAccesoryDF))
	JacD = distJaccard(t(RareAccesoryDF))
	JacCor = c(JacCor, cor(JacD_tot, JacD))
	phyloJacCor = c(phyloJacCor, cor(c(as.matrix(PhyloDistMatrix[colnames(RareAccesoryDF), colnames(RareAccesoryDF)])), c(as.matrix(JacD))))
	jacDist_tracker  = cbind(jacDist_tracker ,c(as.matrix(JacD)))
	bakersGam = c(bakersGam,cor_bakers_gamma(hclust(JacD_tot), hclust(JacD)))
	phylobakersGam = c(phylobakersGam,cor_bakers_gamma(tree2_pruned, hclust(JacD)))

	dends=dendlist(dends, as.dendrogram(hclust(JacD)))

	fullcount = as.matrix((RareAccesoryDF))
	phseqAbundance = otu_table(as.data.frame.matrix(fullcount),taxa_are_rows=TRUE)

	sampledata = sample_data(ANVIO_cat3)
	sample_names(sampledata) = sample_names(phseqAbundance)
	phyloseq = phyloseq(phseqAbundance, sampledata)

    iMDS  <- ordinate(phyloseq, "MDS", distance='bray')
    p <- plot_ordination(phyloseq, iMDS, color="group2")
    # Add title to each plot
    p <- p + geom_point(size=1) + scale_colour_manual(values = colors)+ theme(legend.position="none",axis.line = element_line(colour="black"),axis.ticks = element_line(), panel.grid.major = element_blank(), panel.grid.minor = element_blank(),panel.background = element_blank())  + ggtitle(paste("2 - ",57-(i), sep=""))
	braylist[[i]] = p


    iMDS  <- ordinate(phyloseq, "MDS", distance='jaccard')
    pj <- plot_ordination(phyloseq, iMDS,"samples", color="group2") 
    # Add title to each plot
    pj <- pj + geom_point(size=1) + scale_colour_manual(values = colors)+ theme(legend.position="none",axis.line = element_line(colour="black"),axis.ticks = element_line(), panel.grid.major = element_blank(), panel.grid.minor = element_blank(),panel.background = element_blank())+ ggtitle(paste("2 - ",57-(i), sep=""))
	jaccardlist[[i]] = pj

   iMDS  <- ordinate(phyloseq, "MDS", distance='manhattan')
    pm <- plot_ordination(phyloseq, iMDS,"samples", color="group2") 
    # Add title to each plot
    pm <- pm + geom_point(size=1) + scale_colour_manual(values = colors)+ theme(legend.position="none",axis.line = element_line(colour="black"),axis.ticks = element_line(), panel.grid.major = element_blank(), panel.grid.minor = element_blank(),panel.background = element_blank())+ ggtitle(paste("2 - ",57-(i), sep=""))
	manhattanlist[[i]] = pm

	#multiplot(p,pj,cols=2)


}

multiplot(plotlist=braylist,cols=10)
multiplot(plotlist= jaccardlist,cols=10)
multiplot(plotlist= manhattanlist,cols=10)

multiplot(plotlist=braylist[c(1,6,11,16,21,26,31,36,41,46,51)],cols=11)
multiplot(plotlist= jaccardlist[c(1,6,11,16,21,26,31,36,41,46,51)],cols=11)
multiplot(plotlist= manhattanlist[c(1,6,11,16,21,26,31,36,41,46,51)],cols=11)

multiplot(plotlist=braylist[c(1,12,22,32,42,47,50,52,53,54,55)],cols=11)
multiplot(plotlist= jaccardlist [c(1,12,22,32,42,47,50,52,53,54,55)],cols=11)
multiplot(plotlist= manhattanlist [c(1,12,22,32,42,47,50,52,53,54,55)],cols=11)


ggplot(data=mt,aes(x=phylo,y= value,color=57-X2))+geom_point(size=1)+theme(axis.line = element_line(colour="black"),axis.ticks = element_line(), panel.grid.major = element_blank(), panel.grid.minor = element_blank(),panel.background = element_blank())

ggplot(data=mt,aes(x=phylo,y= value,color=57-X2))+geom_point()+theme(axis.line = element_line(colour="black"),axis.ticks = element_line(), panel.grid.major = element_blank(), panel.grid.minor = element_blank(),panel.background = element_blank())+facet_wrap(~as.factor(X2))



par(mfrow=c(2,2))
plot(lowerLimit, ngenes, xlab="Shared among n genomes", ylab="Number of Genes")
lines(lowerLimit, ngenes, pch=2, lty=2)
plot(lowerLimit, JacCor, xlab="Shared among n genomes", ylab="Correlation of Jaccard distances")
lines(lowerLimit, JacCor, pch=2, lty=2)
plot(lowerLimit, phyloJacCor, xlab="Shared among n genomes", ylab="Correlation of Jaccard distances")
lines(lowerLimit, phyloJacCor, pch=2, lty=2)

plot(lowerLimit, bakersGam, xlab="Shared among n genomes", ylab="Baker's Gamma")


plot(lowerLimit, phylobakersGam, xlab="Shared among n genomes", ylab="Baker's Gamma")



corrplot(cor.dendlist(dends,method="cophenetic"), "pie", "lower",main='cophenetic')
corrplot(cor.dendlist(dends,method="baker"), "pie", "lower",main='baker')
corrplot(cor.dendlist(dends,,method="common_nodes"), "pie", "lower",main='common_nodes')
corrplot(cor.dendlist(dends,method="FM_index",k=10), "pie", "lower",main="FM_index, k=10")



library(fpc)


#dissimilarity matrices
dist_bray <- distance(phyloseq, method = "bray")
dist_js <- distance(phyloseq, method="jaccard")
dist_man <- distance(phyloseq, method="manhattan")


ps_bray <- prediction.strength(dist_bray, Gmin = 2, Gmax = 10,M=10, clustermethod = kmeansCBI)
ps_js <- prediction.strength(dist_js, Gmin = 2, Gmax = 10,M=10, clustermethod = kmeansCBI)
ps_rjs <- prediction.strength(dist_man,Gmin = 2, Gmax = 10,M=10, clustermethod = kmeansCBI)

plot_cluster_validation = function(bray,js,rjs, legend=T,...) {
  plot(2: 10, bray, type="b", pch=1, xlab="Number of Clusters", ...)
  lines(2: 10, js, type="b", pch=2, lty=2)
  lines(2: 10, rjs, type="b", pch=22, lty=3)
  if(legend) legend("topright", legend = c("Bray-Curtis","Jaccard", "Manhattan"), pch=c(1,2,22), lty=1:3)
}

plot_cluster_validation(ps_bray$mean.pred[2: 10], ps_js$mean.pred[2: 10], ps_rjs$mean.pred[2: 10], ylab="Prediction Strength",ylim=c(0,1.1),legend=T)
abline(.9,0, lty=5, col="grey70")
abline(0.8,0,lty=8, col="grey70")
text("Strong support", x=9,y=1, col="grey70")
text("Moderate support", x=9, y=.85, col="grey70")
text("Little or no support", x=9, y=.6, col="grey70")

library(cluster)
pam_bray = sapply(2:10, function(i) pam(dist_bray, k=i, cluster.only = T))
pam_js = sapply(2:10, function(i) pam(dist_js, k=i, cluster.only = T))
pam_rjs = sapply(2:10, function(i) pam(dist_man, k=i, cluster.only = T))


ch_bray = apply(pam_bray, 2, function(i) cluster.stats(dist_bray, i)$ch)
ch_js = apply(pam_js, 2, function(i) cluster.stats(dist_js, i)$ch)
ch_rjs = apply(pam_rjs, 2, function(i) cluster.stats(dist_man, i)$ch)

plot_cluster_validation(ch_bray, ch_js, ch_rjs, legend=T, ylab="Calinski-Harabasz score",ylim=c(0,15))



#----------------------------------------------
#	extract accessory genes
#----------------------------------------------
AccesoryDF = PA_AnvioData[!rowSums(PA_AnvioData)==1, ]
AccesoryDF  = AccesoryDF[! rowSums(AccesoryDF)== length(colnames(AccesoryDF)), ]
#RareAccesoryDF  = AccesoryDF[!rowSums(AccesoryDF)<7,]
#GRareAccesoryDF  = AccesoryDF[!rowSums(AccesoryDF)>10,]
#GRareAccesoryDF  = GRareAccesoryDF[!rowSums(GRareAccesoryDF)<2,]

heatmap.2(as.matrix(t(RareAccesoryDF)),trace='none',scale='column',col=colorRampPalette(brewer.pal(9, "RdBu"))(100))
heatmap.2(as.matrix(t(RareAccesoryDF)),trace='none',scale='column',col=colorRampPalette(c('red','black','green'))(n = 150), RowSideColors= cladecolors)
heatmap.2(as.matrix(t(RareAccesoryDF)),trace="none",col = colorRampPalette(c('white','black'))(100),labCol = FALSE,margins = c(2, 20),RowSideColors= cladecolors)

AccesoryDF = t(AccesoryDF)
#force row order so that it matches the order of leafs in rep_tree_d
clade_order <- order.dendrogram(rep_tree_d)
clade_name <- labels(rep_tree_d)
clade_position <- data.frame(clade_name,clade_order)
clade_position <- clade_position[order(clade_position$clade_order),]
new_order <- match(clade_position$clade_name, row.names(AccesoryDF))
combined_ordered_matrix <- AccesoryDF[new_order,]

heatmap.2(as.matrix(combined_ordered_matrix),trace="none",col = inferno(75),Rowv= rep_tree_d,labCol = FALSE,margins = c(2, 20),dendrogram="row")




pca.test = cbind(t(RareAccesoryDF),as.factor(ANVIO_cat$group))
Og.pca <- PCA(pca.test, quali.sup= ncol(pca.test),graph = FALSE)
plot(Og.pca , habillage = ncol(pca.test), col.hab = c("green", "blue", "red",'orange','purple'), title = "Dataset projected onto PC1-2 Subspace",cex=2,centre = NULL)

ANVIO_cat = ANVIO_cat[ANVIO_cat$name %in% CheckMANVIO2$Bin_Id,]
cols = colorRampPalette(brewer.pal(9, "RdYlBu"))(length(unique(ANVIO_cat$group2)))
ANVIO_cat $color <- factor(ANVIO_cat$group2, labels = cols)
pcacolors <- ANVIO_cat$color

pcacolors2 = pcacolors
names(pcacolors2) = ANVIO_cat$name
pfam_colors = pcacolors2[rownames(PfamData)]


pcacolors = cladecolors
names(pcacolors) = CheckMANVIO2$Bin_Id

############
# 	determining optimal k
############

my_data <- scale(dist(t(RareAccesoryDF))
set.seed(123)


# Elbow method
k1 = fviz_nbclust(my_data, kmeans, method = "wss",k.max=30) +
  labs(subtitle = "Elbow method")

# Silhouette method
k2 = fviz_nbclust(my_data, kmeans, method = "silhouette",k.max= 30)+
  labs(subtitle = "Silhouette method")

# Gap statistic
k3 = fviz_nbclust(my_data, kmeans, nstart = 25,  method = "gap_stat", nboot = 500,k.max= 30)+
  labs(subtitle = "Gap statistic method")

multiplot(k1,k2,k3,cols=3)

############
# 	exploration with PCA
############


MAPLE2 = MAPLE2[,colnames(MAPLE2) %in%CheckMANVIO2$Bin_Id]
fviz_pca_var(res.pca,select.var = list(contrib = 10),col.var="contrib")+scale_color_gradient2(low="white", mid="blue", high="red")

res.pca <- prcomp(t(RareAccesoryDF))
fviz_screeplot(res.pca, addlabels = FALSE,barfill="black", barcolor ="black", linecolor ="red",ncp = 100)+ scale_y_continuous(expand = c(0, 0))+ theme_classic()


res.pca <- prcomp(t(geneCount))

fviz_pca_var(res.pca, col.var = "contrib",
             gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"), repel = TRUE)




cont1 = fviz_contrib(res.pca, choice = "var", axes = 1, top = 100)
cont2 = fviz_contrib(res.pca, choice = "var", axes = 2, top = 100) 
cont3 = fviz_contrib(res.pca, choice = "var", axes = 3, top = 100)
multiplot(cont1,cont2,cont3,cols=1)

fcont1  = fviz_contrib(res.pca, choice="var", axes = 1, fill = "lightgray", color = "black") + theme_classic() + theme(axis.text.x = element_text(angle=45,size=2))
fcont2  = fviz_contrib(res.pca, choice="var", axes = 2, fill = "lightgray", color = "black") + theme_classic() + theme(axis.text.x = element_text(angle=45,size=2))
fcont3  = fviz_contrib(res.pca, choice="var", axes = 3, fill = "lightgray", color = "black") + theme_classic() + theme(axis.text.x = element_text(angle=45,size=2))
fcont4  = fviz_contrib(res.pca, choice="var", axes = 4, fill = "lightgray", color = "black") + theme_classic() + theme(axis.text.x = element_text(angle=45,size=2))
fcont5  = fviz_contrib(res.pca, choice="var", axes = 5, fill = "lightgray", color = "black") + theme_classic() + theme(axis.text.x = element_text(angle=45,size=2))
fcont6  = fviz_contrib(res.pca, choice="var", axes = 6, fill = "lightgray", color = "black") + theme_classic() + theme(axis.text.x = element_text(angle=45,size=2))
fcont7  = fviz_contrib(res.pca, choice="var", axes = 7, fill = "lightgray", color = "black") + theme_classic() + theme(axis.text.x = element_text(angle=45,size=2))
fcont8  = fviz_contrib(res.pca, choice="var", axes = 8, fill = "lightgray", color = "black") + theme_classic() + theme(axis.text.x = element_text(angle=45,size=2))
fcont9  = fviz_contrib(res.pca, choice="var", axes = 9, fill = "lightgray", color = "black") + theme_classic() + theme(axis.text.x = element_text(angle=45,size=2))
multiplot(fcont1,fcont2,fcont3,fcont4,fcont5, fcont6 ,fcont7,fcont8,fcont9,cols=3)

fcont1  = fviz_pca_contrib(res.pca, choice="ind", axes = 1, fill = pcacolors[names(sort(-ind$contrib[,'Dim.1']))], color = "black")+ scale_y_continuous(expand = c(0, 0)) + theme_classic() + theme(axis.text.x = element_text(angle=45,size=5,hjust=1))
fcont2  = fviz_pca_contrib(res.pca, choice="ind", axes = 2, fill = pcacolors[names(sort(-ind$contrib[,'Dim.2']))], color = "black")+ scale_y_continuous(expand = c(0, 0)) + theme_classic() + theme(axis.text.x = element_text(angle=45,size=5,hjust=1))
fcont3  = fviz_pca_contrib(res.pca, choice="ind", axes = 3, fill = pcacolors[names(sort(-ind$contrib[,'Dim.3']))], color = "black")+ scale_y_continuous(expand = c(0, 0)) + theme_classic() + theme(axis.text.x = element_text(angle=45,size=5,hjust=1))
fcont4  = fviz_pca_contrib(res.pca, choice="ind", axes = 4, fill = pcacolors[names(sort(-ind$contrib[,'Dim.4']))], color = "black")+ scale_y_continuous(expand = c(0, 0)) + theme_classic() + theme(axis.text.x = element_text(angle=45,size=5,hjust=1))
fcont5  = fviz_pca_contrib(res.pca, choice="ind", axes = 5, fill = pcacolors[names(sort(-ind$contrib[,'Dim.5']))], color = "black")+ scale_y_continuous(expand = c(0, 0)) + theme_classic() + theme(axis.text.x = element_text(angle=45,size=5,hjust=1))
fcont6  = fviz_pca_contrib(res.pca, choice="ind", axes = 6, fill = pcacolors[names(sort(-ind$contrib[,'Dim.6']))], color = "black")+ scale_y_continuous(expand = c(0, 0)) + theme_classic() + theme(axis.text.x = element_text(angle=45,size=5,hjust=1))
fcont7  = fviz_pca_contrib(res.pca, choice="ind", axes = 7, fill = pcacolors[names(sort(-ind$contrib[,'Dim.7']))], color = "black")+ scale_y_continuous(expand = c(0, 0)) + theme_classic() + theme(axis.text.x = element_text(angle=45,size=5,hjust=1))
fcont8  = fviz_pca_contrib(res.pca, choice="ind", axes = 8, fill = pcacolors[names(sort(-ind$contrib[,'Dim.8']))], color = "black")+ scale_y_continuous(expand = c(0, 0)) + theme_classic() + theme(axis.text.x = element_text(angle=45,size=5,hjust=1))
fcont9  = fviz_pca_contrib(res.pca, choice="ind", axes = 9, fill = pcacolors[names(sort(-ind$contrib[,'Dim.9']))], color = "black")+ scale_y_continuous(expand = c(0, 0)) + theme_classic() + theme(axis.text.x = element_text(angle=45,size=5,hjust=1))
multiplot(fcont1,fcont2,fcont3,fcont4,fcont5, fcont6 ,fcont7,fcont8,fcont9,cols=3)

var <- get_pca_var(res.pca)
ind <- get_pca_ind(res.pca)

#Show a list of variables that contribute most to a certain axis
names(head(sort(-var$contrib[,'Dim.7']),20)),]))

#put this into a heatmap to explore the distribution of those variables in the dataset
heatmap.2(as.matrix(t(AnvioData[names(head(sort(-var$contrib[,'Dim.7']),20)),])),trace='none')

head(AnvioData)

#understand which genes are which
DEDUPLICATED[DEDUPLICATED$protein_cluster_id %in% names(head(sort(-var$contrib[,'Dim.7']),20)),]


#plot heatmaps per PC axis with highest contributing variables
for(i in c(1:9)){
	AnvioDataAnnotated = AnvioData[names(head(sort(-var$contrib[,paste("Dim.", i,sep='')]),100)),]
	rownames(AnvioDataAnnotated) = paste(rownames(AnvioDataAnnotated),DEDUPLICATED[DEDUPLICATED$protein_cluster_id %in% rownames(AnvioDataAnnotated), 'COG_FUNCTION'],sep=' - ')
	pdf(paste("100_contribution_PC", i, ".pdf", sep = ""))
	heatmap.2(as.matrix((AnvioDataAnnotated)),trace='none',margin=c(12,12),ColSideColors=cladecolors,col=colorRampPalette(c('white', "grey", "orange",'red'))(n = 20),cexRow=0.3)
	dev.off()
}

for(i in c(1:9)){
	AnvioDataAnnotated = AnvioData[names(head(sort(-var$contrib[,paste("Dim.", i,sep='')]),50)),]
	rownames(AnvioDataAnnotated) = paste(rownames(AnvioDataAnnotated),DEDUPLICATED[DEDUPLICATED$protein_cluster_id %in% rownames(AnvioDataAnnotated), 'COG_FUNCTION'],sep=' - ')
	pdf(paste("50_contribution_PC", i, ".pdf", sep = ""))
	heatmap.2(as.matrix((AnvioDataAnnotated)),trace='none',margin=c(12,12),ColSideColors=cladecolors,col=colorRampPalette(c('white', "grey", "orange",'red'))(n = 20))
	dev.off()
}

PC_axis_contrib = list()
for(i in c(1:5)){
	PC_axis_contrib[[i]] =  names(head(sort(-var$contrib[,paste("Dim.", i,sep='')]),100))
}
venn(PC_axis_contrib)

highestContribperAxis = c()
for(i in c(1:9)){
	highestContribperAxis = c(highestContribperAxis, names(head(sort(-var$contrib[,paste("Dim.", i,sep='')]),10)))
}

AnvioDataAnnotated = AnvioData[highestContribperAxis,]
	rownames(AnvioDataAnnotated) = paste(rownames(AnvioDataAnnotated),DEDUPLICATED[DEDUPLICATED$protein_cluster_id %in% rownames(AnvioDataAnnotated), 'COG_FUNCTION'],sep=' - ')
	heatmap.2(as.matrix((AnvioDataAnnotated)),trace='none',margin=c(12,12),ColSideColors=cladecolors,col=colorRampPalette(c('white', "grey", "orange",'red'))(n = 20))



pca3 = panpca(t(geneCount), scale = 0)

pca3 = panpca(t(RareAccesoryDF), scale = 0)
pca4 = panpca(t(AccesoryDF), scale = 0)
pca5 = panpca(t(AnvioData), scale = 0)
pca6 = panpca((PfamData), scale = 0)
pca7 = panpca((DUFData), scale = 0)
pca8 = panpca(t(MAPLE2), scale = 0)



library(rgl)
layout3d(matrix(1:10, 5, 2,byrow = TRUE),sharedMouse = TRUE)
plot3d(pca3$Scores[,1:3], col= pcacolors, size=12, type='p')
grid3d(c("x", "y+", "z"))
next3d()
plot3d(pca3$Scores[,4:6], col= pcacolors, size=12, type='p')
grid3d(c("x", "y+", "z"))
next3d()

plot3d(pca4$Scores[,1:3], col= pcacolors, size=12, type='p')
grid3d(c("x", "y+", "z"))
next3d()
plot3d(pca4$Scores[,4:6], col= pcacolors, size=12, type='p')
grid3d(c("x", "y+", "z"))
next3d()

plot3d(pca5$Scores[,1:3], col= pcacolors, size=12, type='p')
grid3d(c("x", "y+", "z"))
next3d()
plot3d(pca5$Scores[,4:6], col= pcacolors, size=12, type='p')
grid3d(c("x", "y+", "z"))
next3d()

plot3d(pca6$Scores[,1:3], col= pfam_colors, size=12, type='p')
grid3d(c("x", "y+", "z"))
next3d()
plot3d(pca6$Scores[,4:6], col= pfam_colors, size=12, type='p')
grid3d(c("x", "y+", "z"))
next3d()

plot3d(pca7$Scores[,1:3], col= pfam_colors, size=12, type='p')
grid3d(c("x", "y+", "z"))
next3d()
plot3d(pca7$Scores[,4:6], col= pfam_colors, size=12, type='p')
grid3d(c("x", "y+", "z"))


plot3d(pca6$Scores[,1:3], size=12, type='p',col= pfam_colors)



layout3d(matrix(1:4, 2, 2,byrow = TRUE),sharedMouse = TRUE)
plot3d(pca5$Scores[,1:3], col= pcacolors, size=12, type='p')
rgl.viewpoint(theta=-150,phi=25,zoom = 0.9)
grid3d(c("x+", "y", "z+"))
next3d()
plot3d(pca3$Scores[,1:3], col= pcacolors, size=12, type='p')
rgl.viewpoint(theta=-150,phi=25,zoom = 0.9)
grid3d(c("x+", "y", "z+"))
next3d()
plot3d(pca6$Scores[,1:3], col= pfam_colors, size=12, type='p')
text3d(pca6 $Scores[,1:3],texts=colnames(AnvioData))

rgl.viewpoint(theta=-150,phi=25,zoom = 0.9)
grid3d(c("x+", "y", "z+"))
next3d()
plot3d(pca7$Scores[,1:3], col= pfam_colors, size=12, type='p')
rgl.viewpoint(theta=-150,phi=25,zoom = 0.9)
grid3d(c("x+", "y", "z+"))

rgl.postscript("PCA_rare_access_Pfam_duf.pdf","pdf") 

legend3d("topright", legend = unique(ANVIO_cat$group), pch = 16, col = unique(ANVIO_cat$color), cex=1, inset=c(0.02))


layout3d(matrix(1:1, 1, 1,byrow = TRUE),sharedMouse = TRUE)
rgl.viewpoint(theta=-150,phi=25,zoom = 0.9)

plot3d(pca7$Scores[,1:3], col= pcacolors, size=12, type='p')
text3d(pca7$Scores[,1:3],texts=colnames(AnvioData))


layout3d(matrix(1:4, 2, 2,byrow = TRUE),sharedMouse = TRUE)
pca.test = cbind(t(RareAccesoryDF),as.factor(ANVIO_cat$group))
Og.pca <- PCA(pca.test, quali.sup= ncol(pca.test),graph = FALSE)
plot3d(Og.pca$scores[,1:3], col= pcacolors, size=12, type='t')
grid3d(c("x", "y+", "z"))
text3d(Og.pca$Scores[,1:3],texts=rownames(Og.pca))
text3d(Og.pca$Scores[,1], Og.pca $Scores[,2], Og.pca $Scores[,3],texts=c(rownames(Og.pca $Scores)), cex= 0.7, pos=3)
next3d()
plot3d(Og.pca$scores[,4:6], col= pcacolors, size=12, type='p')
grid3d(c("x", "y+", "z"))
next3d()



pca.test = cbind(t(PfamData),as.factor(ANVIO_cat$group))
Og.pca <- PCA(pca.test, quali.sup= ncol(pca.test),graph = FALSE)

plot3d(Og.pca$scores[,1:3], col= pcacolors, size=12, type='p')
grid3d(c("x", "y+", "z"))
next3d()
plot3d(Og.pca$scores[,4:6], col= pcacolors, size=12, type='p')
grid3d(c("x", "y+", "z"))
next3d()

pca.test = cbind(t(DUFData),as.factor(ANVIO_cat$group))
Og.pca <- PCA(pca.test, quali.sup= ncol(pca.test),graph = FALSE)

plot3d(Og.pca$scores[,1:3], col= pcacolors, size=12, type='p')
grid3d(c("x", "y+", "z"))
next3d()
plot3d(Og.pca$scores[,4:6], col= pcacolors, size=12, type='p')
grid3d(c("x", "y+", "z"))
next3d()

#----------------------------------------------
#	Pearson correlation among samples
#----------------------------------------------
library(proxy)

dd <- as.dist((1 - cor((AnvioData), method='spearman')/2))
ff <- as.dist((1 - cor((AccesoryDF), method='spearman')/2))


heatmap.2(as.matrix(dd,diag=1),col = rev(colorRampPalette(brewer.pal(9, "RdBu"))(100)),trace='none')
heatmap.2(as.matrix(ff,diag=1),col = rev(colorRampPalette(brewer.pal(9, "RdBu"))(100)),trace='none')


#----------------------------------------------
#	Pearson correlation among samples
#----------------------------------------------
plot.fasta(read.fasta('~/DATA/MarinobacterGenomics/PHYLOGENETICS/PHYLOPHLAN/Phylophlan_withGaps.fasta'))

aln = read.alignment(file = '~/DATA/MarinobacterGenomics/2018_ProkComp/concatenated_CORE_AA.fa',format='fasta')
test = dist.alignment(aln,matrix='identity')
heatmap.2(1-as.matrix(test),trace='none')
heatmap.2(as.matrix(test),trace='none')

#----------------------------------------------
#	Network analysis 
#----------------------------------------------

e = cbind()
for (pc in unique(rownames(RareAccesoryDF))){
	anviosub = subset(ANVIO, ANVIO$protein_cluster_id == pc)

	for (genome in unique(anviosub$genome_name)){
  		for (genome2 in unique(anviosub$genome_name)){
  			if((genome != genome2) & (nrow(anviosub)<5)){
  				print(c(genome, genome2))
  				e = rbind(e,c(genome, genome2))
			}
		}
	}
}

net = network(e)
net %v% "group" = as.character(x)
ggnet2(net, color = "group", alpha = 0.75, size = 4, edge.alpha = 0.5)

x = data.frame(name = network.vertex.names(net))
x = merge(x, ANVIO_cat, by = "name", sort = FALSE)$group

#----------------------------------------------
#	distribution of unique genes
# sorted like phylogenetic tree! (plot against tree)
#----------------------------------------------

#ANVIO
TotalPCs = rowSums(AnvioData)
Core_count = rowSums(AnvioData[,colSums(AnvioData)== number_of_genomes ])
only_singletons = AnvioData[,colSums(AnvioData)==1 ]
SummaryPanGenome = data.frame(rowSums(only_singletons))
colnames(SummaryPanGenome) = c('Unique')
SummaryPanGenome$name = rownames(SummaryPanGenome)
SummaryPanGenome$Core = Core_count 
SummaryPanGenome$Accessory = rowSums(AnvioData) - SummaryPanGenome$Core - SummaryPanGenome$Unique
SummaryPanGenome$total = SummaryPanGenome$Unique + SummaryPanGenome$Accessory + SummaryPanGenome$Core
#SummaryPanGenome$conserved = SummaryPanGenome$Core / SummaryPanGenome$total 


#Pfam
TotalDomains = rowSums(PfamData)
Core_Pfam_count = rowSums(PfamData[,colSums(PfamData)== number_of_genomes ])
Pfam_singletons = PfamData[,colSums(PfamData)==1 ]
SummaryPfamPanGenome = data.frame(rowSums(Pfam_singletons))
colnames(SummaryPfamPanGenome) = c('Unique')
SummaryPfamPanGenome$name = rownames(SummaryPfamPanGenome)
SummaryPfamPanGenome$Core = Core_Pfam_count 
SummaryPfamPanGenome$Accessory = rowSums(PfamData) - SummaryPfamPanGenome$Core - SummaryPfamPanGenome$Unique


k1 = ggplot(data= SummaryPanGenome, aes(y=SummaryPanGenome$Unique,x=SummaryPanGenome$name)) + geom_col() + xlab("Genome") + ylab("number of unique PCs") + coord_flip() + scale_y_continuous(expand = c(0, 0)) + theme_bw() + theme(panel.grid = element_blank(), panel.border = element_blank())

DF1 <- melt(SummaryPanGenome, id.var="name")

p1 = ggplot(DF1, aes(x = name, y = value, fill = variable)) + 
  geom_bar(stat = "identity") + xlab("Genome") + ylab("Protein Cluster") + coord_flip() + scale_y_continuous(expand = c(0, 0)) + theme_bw() + theme(panel.grid = element_blank(), panel.border = element_blank())
ggplot(subset(DF1,variable!='Core'), aes(x = variable, y = value)) + geom_boxplot() + xlab("pan-genome devision") + ylab("number of PCs") + scale_y_continuous(expand = c(0, 0)) + theme_bw() + theme(panel.grid = element_blank(), panel.border = element_blank()) + geom_hline(yintercept = unique(Core_count),linetype = 2) + theme_classic()


#----------------------------------------------
#	Polar_histogram using PhenotypicForest package
#----------------------------------------------

DF3 = DF1[DF1$variable!='total',]
names(DF3)=c('name','score','value')
DF4 = right_join(DF3, ANVIO_cat,by=('name'))
DF5 = data.frame(family=DF4$group,item=DF4$name,score=DF4$score,value=DF4$value)

polarHistogram(DF5, familyLabel = TRUE,guides=c(25,50,75),alphaStart=-1.56,circleProportion=0.50)

#----------------------------------------------
#	distribution of unique genes
# sorted like phylogenetic tree! (plot against tree)
#----------------------------------------------
algn  = read.alignment('~/DATA/MarinobacterGenomics/2018_ProkComp/concatenated_CORE_AA.fa', format = "fasta")
algn2 = as.phyDat(algn,type="AA")

dm  <- dist.ml(algn2)
treeUPGMA  <- upgma(dm)
treeNJ  <- NJ(dm)
treeNJRooted =  midpoint.root(treeNJ)
#increasing branch lengths
treeNJRooted_sorted1 <- ladderize(treeNJRooted, right = FALSE)
plot(treeNJRooted_sorted1, main='concatenated_core')
#plot(treeNJRooted_sorted, 'unrooted', main=i)

algn  = read.alignment('~/DATA/MarinobacterGenomics/2018_ProkComp/concatenated_Campbell_AA.fa', format = "fasta")
algn2 = as.phyDat(algn,type="AA")

dm  <- dist.ml(algn2)
treeUPGMA  <- upgma(dm)
treeNJ  <- NJ(dm)
treeNJRooted =  midpoint.root(treeNJ)
#increasing branch lengths
treeNJRooted_sorted2 <- ladderize(treeNJRooted, right = FALSE)
plot(treeNJRooted_sorted2, main='Campbell')
#plot(treeNJRooted_sorted, 'unrooted', main=i)

algn  = read.alignment('~/DATA/MarinobacterGenomics/2018_ProkComp/concatenated_Rinke_AA.fa', format = "fasta")
algn2 = as.phyDat(algn,type="AA")

dm  <- dist.ml(algn2)
treeUPGMA  <- upgma(dm)
treeNJ  <- NJ(dm)
treeNJRooted =  midpoint.root(treeNJ)
#increasing branch lengths
treeNJRooted_sorted3 <- ladderize(treeNJRooted, right = FALSE)
plot(treeNJRooted_sorted3, main='Rinke')
#plot(treeNJRooted_sorted, 'unrooted', main=i)


nrofGenomes = length(unique(ANVIO$genome_name))

CheckM = read.table("~/DATA/MarinobacterGenomics/2018_ProkComp/qa2.txt",header=TRUE,sep="\t")
CheckM2 = subset(CheckM, Completeness > 98)
CheckM2 = subset(CheckM2, Contamination < 0.5)

ggplot(CheckM2, aes(x=Genome_size, y=predicted_genes))+geom_point(size=CheckM2$Contamination) + geom_smooth(method='lm',size=0.5,color='black')

TotalPCs = rowSums(AnvioData)
Core_count = rowSums(AnvioData[,colSums(AnvioData)==71 ])
only_singletons = AnvioData[,colSums(AnvioData)==1 ]
SummaryPanGenome = data.frame(rowSums(only_singletons))
colnames(SummaryPanGenome) = c('Unique')
SummaryPanGenome$name = rownames(SummaryPanGenome)
SummaryPanGenome$Core = Core_count 
SummaryPanGenome$Accessory = rowSums(AnvioData) - SummaryPanGenome$Core - SummaryPanGenome$Unique
SummaryPanGenome$total = SummaryPanGenome$Unique + SummaryPanGenome$Accessory + SummaryPanGenome$Core
SummaryPanGenome$conserved = SummaryPanGenome$Core / SummaryPanGenome$total 


k1 = ggplot(data= SummaryPanGenome, aes(y=SummaryPanGenome$Unique,x=SummaryPanGenome$name)) + geom_col() + xlab("Genome") + ylab("number of unique PCs") + coord_flip() + scale_y_continuous(expand = c(0, 0)) + theme_bw() + theme(panel.grid = element_blank(), panel.border = element_blank())

multiplot(k1, k2,cols=2)

DF1 <- melt(SummaryPanGenome, id.var="name")
p1 = ggplot(DF1, aes(x = name, y = value, fill = variable)) + 
  geom_bar(stat = "identity") + xlab("Genome") + ylab("Protein Cluster") + coord_flip() + scale_y_continuous(expand = c(0, 0)) + theme_bw() + theme(panel.grid = element_blank(), panel.border = element_blank())


#######################################
sp <- specaccum(t(AnvioData), 'random', permutations=100)

#PfamData = t(PfamData)
Pfam_sp <- specaccum(t(PfamData), 'random', permutations=100)

binomix2 <- binomixEstimate(t(AnvioData), K.range=2:15)

summary(binomix2)

summary(sp)
plot(sp, ci.type='poly', col='darkred', lwd=2, ci.lty=0, ci.col='darkred', xlab='Genomes', ylab='Proteins', main='Gene accumulation plot') 
boxplot(sp, col='white', add=TRUE,cex=0.5,pch = 21) 

plot(Pfam_sp, ci.type='poly', col='darkred', lwd=2, ci.lty=0, ci.col='darkblue', xlab='Genomes', ylab='Proteins', main='Gene accumulation plot')
boxplot(Pfam_sp, col='darkblue', add=TRUE,cex=0.5,pch = 21) 

boxplot(Pfam_sp, col='darkgrey', add=TRUE,cex=0.5,pch = 21) 

mods <- fitspecaccum(sp, "arrh")
plot(mods, col="grey",,xlab='Genomes', ylab='Protein Clusters', main='Gene accumulation plot')
boxplot(sp, col = "white", border = "black", lty=1, cex=0.3, add= TRUE)
## Use nls() methods to the list of models
sapply(mods$models, AIC)

plot(sp, ci.type='poly', col='black', lwd=2, ci.lty=0, ci.col='lightskyblue3', xlab='Genomes', ylab='Proteins', main='accumulation plot')
boxplot(sp, col = "white", border = "darkblue", lty=1, cex=0.3, add= TRUE)
par(new = T)
plot(Pfam_sp, ci.type='poly', col='black', lwd=2, ci.lty=0, ci.col='pink', axes=F, xlab=NA, ylab=NA)
boxplot(Pfam_sp, col = "white", border = "darkred", lty=1, cex=0.3, add= TRUE)
axis(side = 4)
mtext(side = 4, line = 3, 'PfamDomains')

#######################################

mods <- fitspecaccum(sp, "arrh")
plot(mods, col="grey",,xlab='Genomes', ylab='Protein Clusters', main='Gene accumulation plot')

## Use nls() methods to the list of models
sapply(mods$models, AIC)

plot(sp, ci.type='poly', col='black', lwd=2, ci.lty=0, ci.col='lightskyblue3', xlab='Genomes', ylab='Proteins', main='accumulation plot')
boxplot(sp, col = "white", border = "darkblue", lty=1, cex=0.3, add= TRUE)

#---- sopen or closed panGENOME --------------
# Estimating if the pan-genome is open or closed based on a Heaps law model
#This function is based on a Heaps law approach suggested by Tettelin et al (2008). The Heaps law model is fitted to the number of new gene clusters observed when genomes are ordered in a random way. The model has two parameters, an intercept and a decay parameter called alpha. If alpha>1.0 the pan-genome is closed, if alpha<1.0< span=""> it is open.
#----------------------------------------------

heaps(AnvioData,n.perm=100)
heaps(PfamData,n.perm=100)

#---- Pan-genome size --------------
#Chao - computes the Choa lower bound estimated number of gene clusters in a pan-genome

chao.PCsize <- chao(AnvioData)
chao.Pfampansize <- chao(PfamData)

#---- Binomial mixture model --------------

binomix <- binomixEstimate(AnvioData, K.range=2:15)
binomix2 <- binomixEstimate(PfamData, K.range=2:15)

# Displaying the BIC.table
binomix$BIC.table
binomix2$BIC.table

# Summary of model
summary(binomix)
summary(binomix2)



#####################################################################################################################
#
#		Distance based approches
#
#####################################################################################################################



result = pvclust(AnvioData, method.dist="cor", method.hclust="ward.D2", nboot=1000)


#---- DISTANCES AND WEIGHTED DISTANCES --------------
#Manhattan and/or Jaccard distances between pan-genome profiles. Jaccard distance is based on similarity of shared genes, while Manhattan distance also includes similarity of lacking a certain gene (which is often recommended).(Snipen and Ussery, 2010)
#----------------------------------------------

#Jaccard distances based on panmatrix
Jdist.blast <- distJaccard(t(RareAccesoryDF))
Jdist.blast.pfam <- distJaccard(t(RarePfamDF))

#manhatten distamces 
Mdist.blast <- distManhattan(t(RareAccesoryDF))
Mdist.blast.pfam <- distManhattan(t(RarePfamDF))

#fluidityy
fluid.blast <- fluidity(t(RareAccesoryDF))
fluid.blast.pfam <- fluidity(t(RarePfamDF))

#---- Protein Clusters --------------


Manhattangroup = meltGroup(as.matrix(Mdist.blast), ANVIO_cat,'group2')
ds <- plyr::ddply(Manhattangroup[Manhattangroup $taxorder != 'itself',] , c("groupX1",'taxorder'),plyr::summarise, mean = mean(value), sd = sd(value))
g.1 = ggplot(ds, aes(x=reorder(groupX1,mean), y= mean, fill= taxorder)) + geom_bar(position=position_dodge(), stat="identity") + geom_errorbar(aes(ymin= mean-sd, ymax= mean +sd),width=.2,position=position_dodge(.9))+ylab('Manhattan distance') + xlab("group") + theme_classic() + theme(legend.position="bottom",axis.text.x = element_text(angle=90,hjust=1))+scale_y_continuous(expand = c(0, 0))+scale_fill_manual(values=c("black","darkgray",'lightgray'))

Manhattangroup2 = meltGroup(as.matrix(Mdist.blast), ANVIO_cat,'SS')
ds <- plyr::ddply(Manhattangroup2[Manhattangroup2$taxorder != 'itself',] , c("groupX1",'taxorder'),plyr::summarise, mean = mean(value), sd = sd(value))
g.2 = ggplot(ds, aes(x=reorder(groupX1,mean), y= mean, fill= taxorder)) + geom_bar(position=position_dodge(), stat="identity") + geom_errorbar(aes(ymin= mean-sd, ymax= mean +sd),width=.2,position=position_dodge(.9))+ylab('Manhattan distance') + xlab("group") + theme_classic() + theme(legend.position="bottom",axis.text.x = element_text(angle=90,hjust=1))+scale_y_continuous(expand = c(0, 0))+scale_fill_manual(values=c("black","darkgray",'lightgray'))

multiplot(g.1, g.2,cols=1)

Jaccardgroup = meltGroup(as.matrix(Jdist.blast), ANVIO_cat,'group2')
ds <- plyr::ddply(Jaccardgroup[Jaccardgroup $taxorder != 'itself',] , c("groupX1",'taxorder'),plyr::summarise, mean = mean(value), sd = sd(value))
g.3 = ggplot(ds, aes(x=reorder(groupX1,mean), y= mean, fill= taxorder)) + geom_bar(position=position_dodge(), stat="identity") + geom_errorbar(aes(ymin= mean-sd, ymax= mean +sd),width=.2,position=position_dodge(.9))+ylab('Jaccard distance') + xlab("group") + theme_classic() + theme(legend.position="bottom",axis.text.x = element_text(angle=90,hjust=1))+scale_y_continuous(expand = c(0, 0))+scale_fill_manual(values=c("black","darkgray",'lightgray'))

Jaccardgroup2 = meltGroup(as.matrix(Jdist.blast), ANVIO_cat,'SS')
ds <- plyr::ddply(Jaccardgroup2[Jaccardgroup2 $taxorder != 'itself',] , c("groupX1",'taxorder'),plyr::summarise, mean = mean(value), sd = sd(value))
g.4 = ggplot(ds, aes(x=reorder(groupX1,mean), y= mean, fill= taxorder)) + geom_bar(position=position_dodge(), stat="identity") + geom_errorbar(aes(ymin= mean-sd, ymax= mean +sd),width=.2,position=position_dodge(.9))+ylab('Jaccard distance') + xlab("group") + theme_classic() + theme(legend.position="bottom",axis.text.x = element_text(angle=90,hjust=1))+scale_y_continuous(expand = c(0, 0))+scale_fill_manual(values=c("black","darkgray",'lightgray'))


multiplot(g.1, g.2, g.3, g.4,cols=2)

#----  Protein domains --------------

Manhattangroup = meltGroup(as.matrix(Mdist.blast.pfam), ANVIO_cat,'group2')
ds <- plyr::ddply(Manhattangroup[Manhattangroup $taxorder != 'itself',] , c("groupX1",'taxorder'),plyr::summarise, mean = mean(value), sd = sd(value))
g.5 = ggplot(ds, aes(x=reorder(groupX1,mean), y= mean, fill= taxorder)) + geom_bar(position=position_dodge(), stat="identity") + geom_errorbar(aes(ymin= mean-sd, ymax= mean +sd),width=.2,position=position_dodge(.9))+ylab('Manhattan distance') + xlab("group") + theme_classic() + theme(legend.position="bottom",axis.text.x = element_text(angle=90,hjust=1))+scale_y_continuous(expand = c(0, 0))+scale_fill_manual(values=c("black","darkgray",'lightgray'))

Manhattangroup2 = meltGroup(as.matrix(Mdist.blast.pfam), ANVIO_cat,'SS')
ds <- plyr::ddply(Manhattangroup2[Manhattangroup2$taxorder != 'itself',] , c("groupX1",'taxorder'),plyr::summarise, mean = mean(value), sd = sd(value))
g.6 = ggplot(ds, aes(x=reorder(groupX1,mean), y= mean, fill= taxorder)) + geom_bar(position=position_dodge(), stat="identity") + geom_errorbar(aes(ymin= mean-sd, ymax= mean +sd),width=.2,position=position_dodge(.9))+ylab('Manhattan distance') + xlab("group") + theme_classic() + theme(legend.position="bottom",axis.text.x = element_text(angle=90,hjust=1))+scale_y_continuous(expand = c(0, 0))+scale_fill_manual(values=c("black","darkgray",'lightgray'))

multiplot(g.5, g.6,cols=1)

Jaccardgroup = meltGroup(as.matrix(Jdist.blast.pfam), ANVIO_cat,'group2')
ds <- plyr::ddply(Jaccardgroup[Jaccardgroup $taxorder != 'itself',] , c("groupX1",'taxorder'),plyr::summarise, mean = mean(value), sd = sd(value))
g.7 = ggplot(ds, aes(x=reorder(groupX1,mean), y= mean, fill= taxorder)) + geom_bar(position=position_dodge(), stat="identity") + geom_errorbar(aes(ymin= mean-sd, ymax= mean +sd),width=.2,position=position_dodge(.9))+ylab('Jaccard distance') + xlab("group") + theme_classic() + theme(legend.position="bottom",axis.text.x = element_text(angle=90,hjust=1))+scale_y_continuous(expand = c(0, 0))+scale_fill_manual(values=c("black","darkgray",'lightgray'))

Jaccardgroup2 = meltGroup(as.matrix(Jdist.blast.pfam), ANVIO_cat,'SS')
ds <- plyr::ddply(Jaccardgroup2[Jaccardgroup2 $taxorder != 'itself',] , c("groupX1",'taxorder'),plyr::summarise, mean = mean(value), sd = sd(value))
g.8 = ggplot(ds, aes(x=reorder(groupX1,mean), y= mean, fill= taxorder)) + geom_bar(position=position_dodge(), stat="identity") + geom_errorbar(aes(ymin= mean-sd, ymax= mean +sd),width=.2,position=position_dodge(.9))+ylab('Jaccard distance') + xlab("group") + theme_classic() + theme(legend.position="bottom",axis.text.x = element_text(angle=90,hjust=1))+scale_y_continuous(expand = c(0, 0))+scale_fill_manual(values=c("black","darkgray",'lightgray'))


multiplot(g.1, g.2, g.3, g.4,cols=2)
multiplot(g.3, g.4,g.7,g.8,cols=2)
multiplot(g.1, g.2,g.5,g.6,cols=2)

#----------------------------------------------
#	Correlate important measures
#----------------------------------------------



PhyloDistMatrix<-cophenetic(tree2)
PhyloDistMatrix = PhyloDistMatrix[rownames(ANIb),rownames(ANIb)]
melt3 = melt(PhyloDistMatrix)

combinedfundphylo = cbind(melt3$value,ANIblong$value,AAIlong$value,melt(as.matrix(Mdist.blast))$value,melt(as.matrix(Jdist.blast))$value)
colnames(combinedfundphylo)=c('phylo','ANIb','AAI','Manhattan','Jaccard')
combinedfundphylo= data.frame(combinedfundphylo)
plot(combinedfundphylo)

combinedfundphylo$taxorder = AAIgroup$taxorder

l1 = ggplot(combinedfundphylo,aes(phylo,ANIb))+geom_point()+geom_smooth(method='loess')+scale_y_reverse()+xlab('cophenetic distance (SCO)')+ylab('ANIb')
l2 = ggplot(combinedfundphylo,aes(phylo,AAI))+geom_point()+geom_smooth(method='loess')+scale_y_reverse()+xlab('cophenetic distance (SCO)')+ylab('AAI')
l3 = ggplot(combinedfundphylo,aes(phylo, Jaccard))+geom_point()+geom_smooth(method='loess')+xlab('cophenetic distance (SCO)')+ylab('Jaccard Distance (accessory genes)')
l4 = ggplot(combinedfundphylo,aes(phylo,Manhattan))+geom_point()+geom_smooth(method='loess')+xlab('cophenetic distance (SCO)')+ylab('Manhattan Distance (accessory genes)')
multiplot(l1,l2,l3,l4,cols=4)

l5 = ggplot(combinedfundphylo,aes(ANIb,phylo))+geom_point()+geom_smooth(method='loess')+scale_y_reverse()+xlab('ANIb')+ylab('cophenetic disstance (SCO)')
l6 = ggplot(combinedfundphylo,aes(ANIb,AAI))+geom_point()+geom_smooth(method='loess')+xlab('ANIb')+ylab('AAI')
l7 = ggplot(combinedfundphylo,aes(ANIb, Jaccard))+geom_point()+geom_smooth(method='loess')+xlab('ANIb')+ylab('Jaccard Distance (accessory genes)')
l8 = ggplot(combinedfundphylo,aes(ANIb,Manhattan))+geom_point()+geom_smooth(method='loess')+xlab('ANIb')+ylab('Manhattan Distance (accessory genes)')
multiplot(l5,l6,l7,l8,cols=4)

combinedfundphylo_molten = melt(combinedfundphylo,id=c('taxorder'))
ggplot(combinedfundphylo_molten,aes(taxorder, value))+geom_boxplot()+facet_wrap(~variable,scales="free_y")

library(GGally)
ggpairs(combinedfundphylo, aes(colour = taxorder, alpha = 0.4),lower = list(continuous = wrap("smooth", 
                      alpha = 0.3,    
                      size=0.1))
)


my_fn <- function(data, mapping, method="loess", ...){
      p <- ggplot(data = data, mapping = mapping) + 
      geom_point() + 
      geom_smooth(method=method, ...)
      p
    }

ggpairs(combinedfundphylo, lower = list(continuous = my_fn))


#----------------------------------------------
#	Following weighting function computes weights for gene cluster according to their distribution in a pan-genome. 
#	When computing distances between genomes or a PCA, it is possible to give weights to the different gene clusters, emphasizing certain aspects. 
#	As proposed by Snipen & Ussery (2010), we have implemented two types of weighting: The default ‘"shell"’ type means gene families occuring 	frequently in the genomes, denoted shell-genes, are given large weight (close to 1) while those occurring rarely are given small weight (close to 0). The opposite is the ‘"cloud"’ type of weighting. Genes observed in a minority of the genomes are referred to as cloud-genes. Presumeably, the ‘"shell"’ weighting will give distances/PCA reflecting a more long-term evolution, since emphasis is put on genes who have just barely diverged away from the core. The ‘"cloud"’ weighting emphasizes those gene clusters seen rarely. Genomes with similar patterns among these genes may have common recent history. A ‘"cloud"’ weighting typically gives a more erratic or ‘noisy’ picture than the ‘"shell"’ weighting. 
#----------------------------------------------

PAPfamData = PfamData
PAPfamData[PAPfamData>1] <- 1 

w <- geneWeights(PfamData,type="shell")
w2 <- geneWeights(PfamData,type="cloud")
v <- geneWeights(PAPfamData,type="shell")
v2 <- geneWeights(PAPfamData,type="cloud")

Mdist.blast <- distManhattan(PfamData)
Jdist.blast <- distJaccard(PfamData)
Mdist1.blast <- distManhattan(PfamData,weights=w)
Mdist2.blast <- distManhattan(PfamData,weights=w2)

PAMdist.blast <- distManhattan(PAPfamData)
PAJdist.blast <- distJaccard(PAPfamData)
PAMdist1.blast <- distManhattan(PAPfamData,weights=w)
PAMdist2.blast <- distManhattan(PAPfamData,weights=w2)

m2 <- melt(as.matrix(Mdist.blast))[melt(upper.tri(as.matrix(Mdist.blast)))$value,]
m3 <- melt(as.matrix(Jdist.blast))[melt(upper.tri(as.matrix(Jdist.blast)))$value,]
m4 <- melt(as.matrix(Mdist1.blast))[melt(upper.tri(as.matrix(Mdist1.blast)))$value,]
m5 <- melt(as.matrix(Mdist2.blast))[melt(upper.tri(as.matrix(Mdist2.blast)))$value,]

m6 <- melt(as.matrix(PAMdist.blast))[melt(upper.tri(as.matrix(PAMdist.blast)))$value,]
m7 <- melt(as.matrix(PAJdist.blast))[melt(upper.tri(as.matrix(PAJdist.blast)))$value,]
m8 <- melt(as.matrix(PAMdist1.blast))[melt(upper.tri(as.matrix(PAMdist1.blast)))$value,]
m9 <- melt(as.matrix(PAMdist2.blast))[melt(upper.tri(as.matrix(PAMdist2.blast)))$value,]


constructedMatrix = data.frame(cbind(m2$value,m3$value,m4$value,m5$value,m6$value,m7$value,m8$value,m9$value))
colnames(constructedMatrix) = c("Manthattan_UW","Jaccard_UW","Manthattan_SW","Manthattan_CW","PA_Manthattan_UW","PA_Jaccard_UW","PA_Manthattan_SW","PA_Manthattan_CW")

q1 = ggplot(constructedMatrix, aes(Manthattan_UW, Jaccard_UW)) + geom_point() + geom_smooth(method="nls", formula=y~SSasymp(x, Asym, R0, lrc), color="red", se=F, fullrange=T) + theme_classic()
q2 = ggplot(constructedMatrix, aes(Manthattan_UW, Manthattan_SW)) + geom_point() + theme_classic()
 #+ geom_smooth(method="nls", formula=y~SSasymp(x, Asym, R0, lrc), color="red", se=F, fullrange=T) 
q3 = ggplot(constructedMatrix, aes(Manthattan_UW, Manthattan_CW)) + geom_point() + theme_classic()
q4 = ggplot(constructedMatrix, aes(PA_Manthattan_UW, PA_Jaccard_UW)) + geom_point() + geom_smooth(method="nls", formula=y~SSasymp(x, Asym, R0, lrc), color="red", se=F, fullrange=T) + theme_classic()
q5 = ggplot(constructedMatrix, aes(PA_Manthattan_UW, PA_Manthattan_SW)) + geom_point() + theme_classic()
 #+ geom_smooth(method="nls", formula=y~SSasymp(x, Asym, R0, lrc), color="red", se=F, fullrange=T) 
q6 = ggplot(constructedMatrix, aes(PA_Manthattan_UW, PA_Manthattan_CW)) + geom_point() + theme_classic()

q7 = ggplot(constructedMatrix, aes(Manthattan_UW,PA_Manthattan_UW)) + geom_point() + geom_smooth(method="nls", formula=y~SSasymp(x, Asym, R0, lrc), color="red", se=F, fullrange=T) + theme_classic()
q8 = ggplot(constructedMatrix, aes(Manthattan_SW, PA_Manthattan_SW)) + geom_point() + theme_classic()
 #+ geom_smooth(method="nls", formula=y~SSasymp(x, Asym, R0, lrc), color="red", se=F, fullrange=T) 
q9 = ggplot(constructedMatrix, aes(Manthattan_CW, PA_Manthattan_CW)) + geom_point() + theme_classic()


multiplot(q1,q4,q7,q2,q5,q8,q3,q6,q9,cols=3)

r1 = ggscatter(constructedMatrix, x = "Manthattan_UW", y = "Jaccard_UW", size = 0.3, rug = TRUE, palette = "jco") +  stat_cor(method = "spearman")+geom_smooth(method="nls", formula=y~SSasymp(x, Asym, R0, lrc), color="red", se=F, fullrange=T)
r4 = ggscatter(constructedMatrix, x = "PA_Manthattan_UW", y = "PA_Jaccard_UW", size = 0.3, rug = TRUE, palette = "jco") +  stat_cor(method = "spearman")+geom_smooth(method="nls", formula=y~SSasymp(x, Asym, R0, lrc), color="red", se=F, fullrange=T)

r7 = ggscatter(constructedMatrix, x = "Manthattan_UW", y = "PA_Manthattan_UW", size = 0.3, rug = TRUE, palette = "jco") +  stat_cor(method = "spearman")+geom_smooth(method="nls", formula=y~SSasymp(x, Asym, R0, lrc), color="red", se=F, fullrange=T)
r2 = ggscatter(constructedMatrix, x = "Manthattan_UW", y = "Manthattan_SW", size = 0.3, rug = TRUE, palette = "jco") +  stat_cor(method = "spearman")+geom_smooth(method="nls", formula=y~SSasymp(x, Asym, R0, lrc), color="red", se=F, fullrange=T)
r5 = ggscatter(constructedMatrix, x = "PA_Manthattan_UW", y = "PA_Manthattan_SW", size = 0.3, rug = TRUE, palette = "jco") +  stat_cor(method = "spearman")+geom_smooth(method="nls", formula=y~SSasymp(x, Asym, R0, lrc), color="red", se=F, fullrange=T)


r8 = ggscatter(constructedMatrix, x = "Manthattan_SW", y = "PA_Manthattan_SW", size = 0.3, rug = TRUE, palette = "jco") +  stat_cor(method = "spearman")+geom_smooth(method="nls", formula=y~SSasymp(x, Asym, R0, lrc), color="red", se=F, fullrange=T)
r3 = ggscatter(constructedMatrix, x = "Manthattan_UW", y = "Manthattan_CW", size = 0.3, rug = TRUE, palette = "jco") +  stat_cor(method = "spearman")+geom_smooth(method="nls", formula=y~SSasymp(x, Asym, R0, lrc), color="red", se=F, fullrange=T)

r6 = ggscatter(constructedMatrix, x = "PA_Manthattan_UW", y = "PA_Manthattan_CW", size = 0.3, rug = TRUE, palette = "jco") +  stat_cor(method = "spearman")+geom_smooth(method="nls", formula=y~SSasymp(x, Asym, R0, lrc), color="red", se=F, fullrange=T)
r9 = ggscatter(constructedMatrix, x = "Manthattan_CW", y = "PA_Manthattan_CW", size = 0.3, rug = TRUE, palette = "jco") +  stat_cor(method = "spearman")+geom_smooth(method="nls", formula=y~SSasymp(x, Asym, R0, lrc), color="red", se=F, fullrange=T)

multiplot(r1,r4,r7,r2,r5,r8,r3,r6,r9,cols=3)




# # Based on these results, we can reject the null hypothesis that these two matrices, spatial distance and ozone distance, are unrelated with alpha = .05. The observed correlation, r = 0.1636308, suggests that the matrix entries are positively associated.  So smaller differences in ozone are generally seen among pairs of stations that are close to each other than far from each other. Note that since this test is based on random permutations, the same code will always arrive at the same observed correlation but rarely the same p-value.
mantel.rtest(Mdist.blast, Jdist.blast, nrepet = 999)


#####################################################################################################################
#
#		PAN TREES
#
#####################################################################################################################

#---- Calculate so called PAN-trees --------------


ANVIOtree <- panTree(t(RareAccesoryDF),nboot=1000)
#PA_ANVIOtree <- panTree(t(PA_AnvioData),nboot=100)
Pfamtree <- panTree(t(RarePfamDF),nboot=100)
#PAPfamtree <- panTree(PAPfamData,nboot=1000)
#DUFtree <- panTree(DUFData,nboot=100)
#PADUFtree <- panTree(PA_DUFData,nboot=100)

as.phylo(ANVIOtree $Htree)

tr1 = ggtree(as.phylo(ANVIOtree $Htree)) %<+% ANVIO_cat + geom_point(aes(color = group2)) + scale_colour_manual(values=colors)+ geom_text2(aes(label=label, subset=!isTip), hjust=1.2,vjust=-.5,size=2)+ggtitle('protein clusters')+geom_treescale()
tr2 = ggtree(as.phylo(Pfamtree $Htree))%<+% ANVIO_cat + geom_point(aes(color = group2)) + scale_colour_manual(values=colors)+ geom_text2(aes(label=label, subset=!isTip), hjust=1.2,vjust=-.5,size=2)+ggtitle('protein domains')+geom_treescale()
tr3 = ggtree(tree2,branch.length='none')%<+% ANVIO_cat + geom_point(aes(color = group2)) + scale_colour_manual(values=colors)+ggtitle('phylogeny')+geom_treescale()

#FUNCTION VS PHYLOGENY
multiplot(tr3,tr1,cols=2)

tree2$edge.length[which(tree2$edge.length == 0)] <- 0.00001
rep_tree_um <- chronopl(tree2,lambda = 0.1,tol = 0)
rep_tree_d <- as.dendrogram(as.hclust.phylo(rep_tree_um))


tanglegram(rep_tree_d,as.dendrogram(as.phylo(ANVIOtree $Htree)))

tr3 = ggtree(rep_tree_um,branch.length='none')%<+% ANVIO_cat + geom_point(aes(color = group2)) + scale_colour_manual(values=colors)+ggtitle('phylogeny')+geom_treescale()
ggtree(tree2,branch.length='none')%<+% ANVIO_cat + geom_point(aes(color = group2)) + scale_colour_manual(values=colors)+ggtitle('phylogeny')+geom_treescale()

#tr4 = ggtree(RAxMLRiboProtRooted)%<+% ANVIO_cat + geom_point(aes(color = group2)) + scale_colour_manual(values=colors)+ geom_text2(aes(label=label, subset=!isTip), hjust=1.2,vjust=-.5,size=2)+ggtitle('Ribosomal Proteins')+geom_treescale()
#multiplot(tr1,tr2,tr3,tr4,cols=4)
multiplot(tr1,tr2,cols=2)

tr1 = ggtree(as.phylo(ANVIOtree $Htree)) %<+% ANVIO_cat + geom_point(aes(color = SS)) + scale_colour_manual(values=Habitat_colors)+ geom_text2(aes(label=label, subset=!isTip), hjust=1.2,vjust=-.5,size=2)+ggtitle('protein clusters')+geom_treescale()
tr2 = ggtree(as.phylo(Pfamtree $Htree))%<+% ANVIO_cat + geom_point(aes(color = SS)) + scale_colour_manual(values= Habitat_colors)+ geom_text2(aes(label=label, subset=!isTip), hjust=1.2,vjust=-.5,size=2)+ggtitle('protein domains')+geom_treescale()
multiplot(tr1,tr2,cols=2)







w <- geneWeights(t(RareAccesoryDF),type="shell")
w2 <- geneWeights(t(RareAccesoryDF),type="cloud")
Mdist.blast <- distManhattan(t(RareAccesoryDF))
Mdist1.blast <- distManhattan(t(RareAccesoryDF),weights=w)
Mdist2.blast <- distManhattan(t(RareAccesoryDF),weights=w2)


#---- neighborNet as split network function --------------
nnet <- neighborNet(Mdist.blast)
#nnet2 <- neighborNet(Mdist.blast.pfam)
nnet3 <- neighborNet(Mdist1.blast)
nnet4 <- neighborNet(Mdist2.blast)
plot(nnet)
plot(nnet3)

plot(nnet4)


#---- neighborNet as split network function --------------

par(mfrow=c(3,2)) 
plot(as.phylo(ANVIOtree $Htree),type="unrooted",no.margin = TRUE,cex=0.3,main='PC abundance')
plot(as.phylo(PA_ANVIOtree$Htree),type="unrooted",no.margin = TRUE,cex=0.3,main='PC PresAbs')
plot(as.phylo(Pfamtree$Htree),type="unrooted",no.margin = TRUE,cex=0.3,main='Domain abundance')
plot(as.phylo(PAPfamtree$Htree),type="unrooted",no.margin = TRUE,cex=0.3,main='Domain PresAbs')
plot(as.phylo(DUFtree$Htree),type="unrooted",no.margin = TRUE,cex=0.3,main='DUF abundance')
plot(as.phylo(PADUFtree $Htree),type="unrooted",no.margin = TRUE,cex=0.3,main='DUF PresAbs')


par(mfrow=c(1,6)) 
plot(ANVIOtree,xlab="Protein Clusters (abundance)",cex=0.75)
plot(PA_ANVIOtree,xlab="Protein Clusters (presence.absence)",cex=0.75)
plot(Pfamtree,xlab="Pfamtree",cex=0.75)
plot(PAPfamtree,xlab="PAPfamtree",cex=0.75)
plot(DUFtree,xlab="DUFPfamtree",cex=0.75)
plot(PADUFtree,xlab="PADUFPfamtree",cex=0.75)


w <- geneWeights(PfamData,type="shell")
v <- geneWeights(PAPfamData,type="shell")

wPfamtree = panTree(Pfamtree, weights=w,nboot = 100)
wPAPfamData = panTree(PAPfamData, weights=v,nboot = 100)

par(mfrow=c(1,2)) 
plot(tree2)
plot(wPfamtree,xlab="weighted Pfam Mantattan distance")
plot(wPAPfamData,xlab="weighted PAPfam domains Mantattan distance")
tanglegram(as.dendrogram(PAPfamtree$Htree),as.dendrogram(wPAPfamData $Htree))
tanglegram(as.dendrogram(PAPfamtree$Htree),as.dendrogram(DUFtree $Htree))

library(ape)
library(phytools)


Phylophlan = read.tree("~/DATA/MarinobacterGenomics/miscl/Oceano_clean.tree.nwk")

PhylophlanRooted =  midpoint.root(Phylophlan)

tree2 <- ladderize(PhylophlanRooted, right = FALSE)

tr = plot(tree2)

is_tip <- tree2$edge[,2] <= length(tree2$tip.label)
ordered_tips <- tree2$edge[is_tip, 2]
tree2$tip.label[ordered_tips]

library(DECIPHER)


force.ultrametric<-function(tree,method=c("nnls","extend")){
    method<-method[1]
    if(method=="nnls") tree<-nnls.tree(cophenetic(tree),tree,
        rooted=TRUE,trace=0)
    else if(method=="extend"){
        h<-diag(vcv(tree))
        d<-max(h)-h
        ii<-sapply(1:Ntip(tree),function(x,y) which(y==x),
            y=tree$edge[,2])
        tree$edge.length[ii]<-tree$edge.length[ii]+d
    } else 
        cat("method not recognized: returning input tree\n\n")
    tree
}

ult.nnls<-force.ultrametric(tree2)
tanglegram(ladderize(ult.nnls, right = FALSE), ladder(as.dendrogram(PAPfamtree$Htree), decreasing = TRUE))

PhyloDistMatrix<-cophenetic(tree2)
PhyloDistMatrix = PhyloDistMatrix[-grep("Marinicella_sp", rownames(PhyloDistMatrix)),-grep("Marinicella_sp", colnames(PhyloDistMatrix))]
PfamDist=dist(PfamData)
PfamDist  = PfamDist[ order(row.names(PfamDist)), ]
PfamDist  = PfamDist[ , order(colnames(PfamDist))]
DUFdist = distManhattan(DUFData)
PhyloDistMatrix  = PhyloDistMatrix[ order(row.names(PhyloDistMatrix)), ]
PhyloDistMatrix  = PhyloDistMatrix[ , order(colnames(PhyloDistMatrix))]
Mdist.blast = Mdist.blast[ , order(colnames(Mdist.blast))]
Jdist.blast = Jdist.blast[ , order(colnames(Jdist.blast))]
AAI  = AAI[ , order(colnames(AAI))]
AAI  = AAI[ order(row.names(AAI)), ]
OF  = OF[ , order(colnames(OF))]
OF  = OF[ order(row.names(OF)), ]
Og  = Og[ , order(colnames(Og))]
Og  = Og[ order(row.names(Og)), ]
#distTips(tree)
Mdist.blast
m2 <- melt(as.matrix(PfamDist))[melt(upper.tri(as.matrix(PfamDist)))$value,]
m3 <- melt(as.matrix(PhyloDistMatrix))[melt(upper.tri(as.matrix(PhyloDistMatrix)))$value,]
m4 <- melt(as.matrix(Mdist.blast))[melt(upper.tri(as.matrix(Mdist.blast)))$value,]
m5 <- melt(as.matrix(Jdist.blast))[melt(upper.tri(as.matrix(Jdist.blast)))$value,]
#m6 <- melt(as.matrix(PAJdist.blast))[melt(upper.tri(as.matrix(PAJdist.blast)))$value,]
m7 <- melt(as.matrix(DUFdist))[melt(upper.tri(as.matrix(DUFdist)))$value,]
m8=melt(as.matrix(AAI))[melt(upper.tri(as.matrix(AAI)))$value,]
m10 = melt(as.matrix(OF))[melt(upper.tri(as.matrix(OF)))$value,]
m11 = melt(as.matrix(Og))[melt(upper.tri(as.matrix(Og)))$value,]


DUFdist

constructedMatrix = data.frame(cbind(m2$value,m3$value,m4$value,m5$value,m7$value,m8$value,m10$value,m11$value))
colnames(constructedMatrix) = c("Pfam","phylogeny","PfamManhat",'JaccardPfam','DUFdist','AAI','Orthologous_fraction','nr_of_orthologs')

g1 = ggplot(constructedMatrix, aes(phylogeny, Pfam)) + geom_point(size=0.3) + geom_smooth(method="nls", formula=y~SSasymp(x, Asym, R0, lrc), color="red", se=F, fullrange=T)  +  geom_smooth(color="lightgrey", se=F, fullrange=T) + theme_classic()
g2 = ggplot(constructedMatrix, aes(phylogeny, PfamManhat)) + geom_point(size=0.3) + geom_smooth(method="nls", formula=y~SSasymp(x, Asym, R0, lrc), color="red", se=F, fullrange=T)  +  geom_smooth(color="lightgrey", se=F, fullrange=T) + theme_classic()
g3 = ggplot(constructedMatrix, aes(phylogeny, JaccardPfam)) + geom_point(size=0.3) + geom_smooth(method="nls", formula=y~SSasymp(x, Asym, R0, lrc), color="red", se=F, fullrange=T)  +  geom_smooth(color="lightgrey", se=F, fullrange=T) + theme_classic()
g5 = ggplot(constructedMatrix, aes(phylogeny, DUFdist)) + geom_point(size=0.3) + geom_smooth(method="nls", formula=y~SSasymp(x, Asym, R0, lrc), color="red", se=F, fullrange=T) +  geom_smooth(color="lightgrey", se=F, fullrange=T) + theme_classic()
g6 = ggplot(constructedMatrix, aes(phylogeny, 100-AAI)) + geom_point(size=0.3) + geom_smooth(method="nls", formula=y~SSasymp(x, Asym, R0, lrc), color="red", se=F, fullrange=T) +  geom_smooth(color="lightgrey", se=F, fullrange=T) + theme_classic()
multiplot(g6,g1,g2,g3,g5,cols=2)
g8 = ggplot(constructedMatrix, aes(PfamManhat, DUFdist)) + geom_point(size=0.3) + geom_smooth(method="lm", color="red", se=F, fullrange=T) +  geom_smooth(color="lightgrey", se=F, fullrange=T) + theme_classic()
g7 = ggplot(constructedMatrix, aes(phylogeny, 100-Orthologous_fraction)) + geom_point(size=0.3) + geom_smooth(method="nls", formula=y~SSasymp(x, Asym, R0, lrc), color="red", se=F, fullrange=T) +  geom_smooth(color="lightgrey", se=F, fullrange=T) + theme_classic()
g82 = ggplot(constructedMatrix, aes(phylogeny, nr_of_orthologs)) + geom_point(size=0.3) + geom_smooth(method="nls", formula=y~SSasymp(x, Asym, R0, lrc), color="red", se=F, fullrange=T) +  geom_smooth(color="lightgrey", se=F, fullrange=T) + theme_classic()
g9 = ggplot(constructedMatrix, aes(100-AAI, nr_of_orthologs)) + geom_point(size=0.3) + geom_smooth(method="lm", color="red", se=F, fullrange=T) +  geom_smooth(color="lightgrey", se=F, fullrange=T) + theme_classic()
g10 = ggplot(constructedMatrix, aes(AAI, Orthologous_fraction)) + geom_point(size=0.3) + geom_smooth(method="lm", color="red", se=F, fullrange=T) +  geom_smooth(color="lightgrey", se=F, fullrange=T) + theme_classic()
g11 = ggplot(constructedMatrix, aes(AAI, nr_of_orthologs)) + geom_point(size=0.3) + geom_smooth(method="lm", color="red", se=F, fullrange=T) +  geom_smooth(color="lightgrey", se=F, fullrange=T) + theme_classic()

mantel.rtest(PhyloDistMatrix, PfamDist, nrepet = 999)


multiplot(g6,g1,g3,g2,g5,g7,g8,g9, g82,g10,g11,cols=3)

##########################
# FUNCTION GREP
##########################

mat = t(table(droplevels(ANVIO[grepl(c("quinone| malate | NADH"),ANVIO$COG_FUNCTION,ignore.case=TRUE),][,c('COG_FUNCTION','genome_name')])))
mat = t(table(droplevels(subset(ANVIO, COG_FUNCTION  %in% PathMerged$cog)[,c('COG_FUNCTION','genome_name')])))

heatmap.2(as.matrix(t(mat)),trace="none"
,col = inferno(75),srtCol=45,cexRow=0.5,cexCol=0.6,main='fructose',margins=c(10,20))




##########################
#KEGG
# KEGG and COG intervoncersion in based on the ko2kegg file on the KEGG ftp server
# file download the file from http://www.genome.jp/kegg/files/ko2cog.xl##########################
##########################
##########################################
##########################################

# Run this only if you need to, as it takes couple of hours
#extPath = c()
#for (i in ko2COG2$KO){
#	tryCatch({
#		print(i)
#       lkp <- keggGet(i)
# 	    infExtract=c(KO = i, KEGG_NAME = lkp[[1]]$NAME,KEGG_DEFINITION = lkp[[1]]$DEFINITION)
#        extPath = rbind(extPath, infExtract)
#     }, error=function(e){cat("ERROR :",conditionMessage(e), "\n")})
#}
# write.table(data.frame(extPath),file = 'KO_annotation2.txt', sep = "\t")
##########################################
##########################################


library(KEGGREST)
library(stringr)

ko2COG = read.table("~/ko2cog.xl.txt",header=TRUE,sep='\t')
ko2COG2 = ko2COG
ko2COG2$COG_FUNCTION_ACC = gsub(" ","-",str_sub(ko2COG2$COG,6,-2))

ko2COG_annotated2 = read.table("~/KO_annotation2.txt",header=TRUE,sep='\t')
ko2COG_annotated3 = merge(ko2COG_annotated2, ko2COG2,by='KO')
ANVIOKEGG = merge(ANVIO, ko2COG_annotated3,by='COG_FUNCTION_ACC')



org <- keggList("pathway")
head(org)
org <- keggList("organism")
head(org)
org <- keggList("ko")
head(org)
queryables <- c(listDatabases(), org[,1], org[,2])
# the following selects a KEGG pathway and merges, and beautifies the associated COG identifiers into a single dataframe
query <- keggGet("ko00020") 
query <- keggGet("ko02010")

PathwKEGGset = data.frame(query[[1]]$ORTHOLOGY)

names(PathwKEGGset) = c("kegg_function")


# write.table(data.frame(extPath),file = 'KO_annotation2.txt', sep = "\t")
##########################################
##########################################


COG_list = c("D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R","S","T","U","V","W","X" )
sum=0
mat = t(table(droplevels(ANVIO[grep("C", ANVIO $COG_CATEGORY),c('COG_FUNCTION','genome_name')])))
CpcogFull = data.frame(rowSums(mat))
for(i in COG_list){
	mat = t(table(droplevels(ANVIO[grep(i, ANVIO$COG_CATEGORY),c('COG_FUNCTION','genome_name')])))
	CpcogFull = cbind(CpcogFull,rowSums(mat))
}
names(CpcogFull)= c("C","D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R","S","T","U","V","W","X")

ANVIO_cat2 = ANVIO_cat
names(ANVIO_cat2)=c('Bin_Id','group','group2','lifestyle','SS','sourceClass','lat','lon','color')
CpcogFull = right_join(CpcogFull, ANVIO_cat2, by=c('Bin_Id'))


ggplot(CpcogFull ,aes(x= group2,y=GC))+geom_boxplot()+xlab('lineage')+ylab('C \n (genes per Mbp)')+  theme_classic()+theme(axis.text.x=element_text(angle=45))


CpcogFull2 = subset(CpcogFull,group2 %in% c('algicola','adhaerens'))
ggplot(CpcogFull2 ,aes(x= group,y=C/(Genome_size/1000000)))+geom_boxplot()+xlab('lineage')+ylab('C \n (genes per Mbp)')+  theme_classic()+theme(axis.text.x=element_text(angle=45))


CheckM2 = subset(CheckM, Completeness > 98)
CheckM2 = CheckM2[order(CheckM2$Bin_Id),]



ggboxplot(CpcogFull, x = "group2",
          y = c("GC","Coding_density","predicted_genes"),
          combine = TRUE,
          color = "group2", palette = "jco",
          ylab = "GC", 
          add = "jitter", add.params = list(size = 0.1, jitter = 0.2) )+  theme_classic()+theme(axis.text.x=element_text(angle=45,hjust=1))



moltenCOG = melt(CpcogFull)

ggboxplot(moltenCOG, x = "variable", y = "value", color = "variable", 
          add = "jitter", legend = "none",add.params = list(size = 0.5, jitter = 0.2)) +
  rotate_x_text(angle = 45)+
  geom_hline(yintercept = mean(moltenCOG$value), linetype = 2,color="grey") +  stat_compare_means(method = "kruskal", label.y = 200)
  
  ggboxplot(moltenCOG, x = "variable", y = "value", add = "jitter", legend = "none",add.params = list(size = 0.5, jitter = 0.2)) +
  rotate_x_text(angle = 45)+
  geom_hline(yintercept = mean(moltenCOG$value), linetype = 2,color="grey") +  stat_compare_means(method = "kruskal", label.y = 200)
  
  
CpcogFull = cbind(CpcogFull, Bin_Id = rownames(CpcogFull))

CpcogFull = right_join(CpcogFull, CheckM2, by=c('Bin_Id'))
CpcogFull = right_join(CpcogFull, ANVIO_cat2, by=c('Bin_Id'))


  
 ggplot(CpcogFull, aes(x= Genome_size, y= predicted_genes)) + 
    geom_point(aes(color=group2)) +      # Thinner lines
    theme_bw()
    
    
    
ggscatter(CpcogFull, x = "Genome_size", y = "predicted_genes", size = 0.3, 
          rug = TRUE, color = "group2", palette = "jco") + stat_cor(aes(color = group2), method = "spearman")
          
          
ggscatter(CpcogFull, x = "Genome_size", y = "predicted_genes", size = 0.3,
          color = "group2", palette = "jco",
          facet.by = "group2", #scales = "free_x",
          add = "reg.line", conf.int = TRUE) +
  stat_cor(aes(color = group2), method = "spearman", label.y = 6)





pmain <- ggplot(CpcogFull2, aes(x = Genome_size, y = predicted_genes, color = group2))+
  geom_point()+
  ggpubr::color_palette("jco")
# Marginal densities along x axis
xdens <- axis_canvas(pmain, axis = "x")+
  geom_density(data = CpcogFull2, aes(x = Genome_size, fill = group2),
              alpha = 0.7, size = 0.2)+
  ggpubr::fill_palette("jco")
# Marginal densities along y axis
# Need to set coord_flip = TRUE, if you plan to use coord_flip()
ydens <- axis_canvas(pmain, axis = "y", coord_flip = TRUE)+
  geom_density(data = CpcogFull2, aes(x = predicted_genes, fill = group2),
                alpha = 0.7, size = 0.2) + coord_flip()+ ggpubr::fill_palette("jco")
p1 <- insert_xaxis_grob(pmain, xdens, grid::unit(.2, "null"), position = "top")
p2<- insert_yaxis_grob(p1, ydens, grid::unit(.2, "null"), position = "right")
ggdraw(p2)



sp <- ggscatter(CpcogFull2, x = "Genome_size", y = "predicted_genes",
                color = "group2", palette = "jco",
                size = 1, alpha = 1, ggtheme = theme_bw())             
# Marginal boxplot of x (top panel) and y (right panel)
xplot <- ggboxplot(CpcogFull2, x = "group2", y = "Genome_size", 
                   color = "group2", fill = "group2", palette = "jco",
                   alpha = 0.5, ggtheme = theme_bw())+coord_flip()# rotate()
yplot <- ggboxplot(CpcogFull2, x = "group2", y = "predicted_genes",
                   color = "group2", fill = "group2", palette = "jco",
                   alpha = 0.5, ggtheme = theme_bw())
# Cleaning the plots
sp <- sp + rremove("legend")
yplot <- yplot + clean_theme() + rremove("legend")
xplot <- xplot + clean_theme() + rremove("legend")
# Arranging the plot using cowplot
#library(cowplot)
plot_grid(xplot, NULL, sp, yplot, ncol = 2, align = "hv", 
          rel_widths = c(2, 1), rel_heights = c(1, 2))


sp <- ggscatter(CpcogFull, x = "Genome_size", y = "predicted_genes",
                color = "group2", palette = "jco",
                size = 1, alpha = 1, ggtheme = theme_bw(),rug=TRUE)             
# Marginal boxplot of x (top panel) and y (right panel)
xplot <- ggboxplot(CpcogFull, x = "group2", y = "Genome_size", 
                   color = "group2", fill = "group2", palette = "jco",
                   alpha = 0.5, ggtheme = theme_bw(),add = "jitter", add.params = list(size = 0.5, jitter = 0.2))+coord_flip()# rotate()
yplot <- ggboxplot(CpcogFull, x = "group2", y = "predicted_genes",
                   color = "group2", fill = "group2", palette = "jco",
                   alpha = 0.5, ggtheme = theme_bw(),add = "jitter", add.params = list(size = 0.5, jitter = 0.2))+theme(axis.text.x=element_text(angle=45,hjust=1))
# Cleaning the plots
sp <- sp + rremove("legend")
yplot <- yplot + rremove("legend")
xplot <- xplot  + rremove("legend")
# Arranging the plot using cowplot
#library(cowplot)
plot_grid(xplot, NULL, sp, yplot, ncol = 2, align = "hv", 
          rel_widths = c(2, 1), rel_heights = c(1, 2))
          
          
          
sp <- ggscatter(CpcogFull, x = "Coding_density", y = "GC",
                color = "group2", palette = "jco",
                size = 1, alpha = 1, ggtheme = theme_bw(),rug=TRUE)             
# Marginal boxplot of x (top panel) and y (right panel)
xplot <- ggboxplot(CpcogFull, x = "group2", y = "Coding_density", 
                   color = "group2", fill = "group2", palette = "jco",
                   alpha = 0.5, ggtheme = theme_bw(),add = "jitter", add.params = list(size = 0.5, jitter = 0.2))+coord_flip()# rotate()
yplot <- ggboxplot(CpcogFull, x = "group2", y = "PC",
                   color = "group2", fill = "group2", palette = "jco",
                   alpha = 0.5, ggtheme = theme_bw(),add = "jitter", add.params = list(size = 0.5, jitter = 0.2))+theme(axis.text.x=element_text(angle=45,hjust=1))
# Cleaning the plots
sp <- sp + rremove("legend")
yplot <- yplot + rremove("legend")
xplot <- xplot  + rremove("legend")
# Arranging the plot using cowplot
#library(cowplot)
plot_grid(xplot, NULL, sp, yplot, ncol = 2, align = "hv", 
          rel_widths = c(2, 1), rel_heights = c(1, 2))
          
          
          
